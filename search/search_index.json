{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Simple and Fast Geospatial Features API for PostGIS. Documentation : developmentseed.org/tifeatures/ Source Code : developmentseed/tifeatures TiFeatures , pronounced T[ee]Features , is a python package which helps creating lightweight Features server for PostGIS Database. The API has been designed with respect to OGC Features API specification . Install \u00b6 $ python -m pip install pip -U $ python -m pip install tifeatures # or from source $ git clone https://github.com/developmentseed/tifeatures.git $ cd tifeatures $ python -m pip install -e . OGC Specification \u00b6 Specification Status link Part 1: Core \u2705 docs.ogc.org/is/17-069r4/17-069r4.html Part 2: CRS by Reference \u274c docs.ogc.org/is/18-058r1/18-058r1.html Part 3: Filtering / CQL2 \u2705 docs.ogc.org/DRAFTS/19-079r1.html Notes: The project authors choose not to implement the Part 2 of the specification to avoid the introduction of CRS based GeoJSON. This might change in the future. While the authors tried to follow the specification (part 1 and 3) to the letter, some API endpoints might have more capacities (e.g geometry column selection). PostGIS/Postgres \u00b6 TiFeatures rely a lot of ST_* PostGIS functions. You need to make sure your Postgres database has Postgis installed. SELECT name , default_version , installed_version FROM pg_available_extensions WHERE name LIKE 'postgis%' or name LIKE 'address%' ; CREATE EXTENSION postgis ; Configuration \u00b6 To be able to work, the application will need access to the database. tifeatures uses starlette 's configuration pattern which make use of environment variable and/or .env file to pass variable to the application. Example of .env file can be found in .env.example # you need define the DATABASE_URL directly DATABASE_URL=postgresql://username:password@0.0.0.0:5432/postgis Launch \u00b6 $ pip install uvicorn # Set your postgis database instance URL in the environment $ export DATABASE_URL = postgresql://username:password@0.0.0.0:5432/postgis $ uvicorn tifeatures.main:app # or using Docker $ docker-compose up Contribution & Development \u00b6 See CONTRIBUTING.md License \u00b6 See LICENSE Authors \u00b6 Created by Development Seed Changes \u00b6 See CHANGES.md .","title":"TiFeatures"},{"location":"#install","text":"$ python -m pip install pip -U $ python -m pip install tifeatures # or from source $ git clone https://github.com/developmentseed/tifeatures.git $ cd tifeatures $ python -m pip install -e .","title":"Install"},{"location":"#ogc-specification","text":"Specification Status link Part 1: Core \u2705 docs.ogc.org/is/17-069r4/17-069r4.html Part 2: CRS by Reference \u274c docs.ogc.org/is/18-058r1/18-058r1.html Part 3: Filtering / CQL2 \u2705 docs.ogc.org/DRAFTS/19-079r1.html Notes: The project authors choose not to implement the Part 2 of the specification to avoid the introduction of CRS based GeoJSON. This might change in the future. While the authors tried to follow the specification (part 1 and 3) to the letter, some API endpoints might have more capacities (e.g geometry column selection).","title":"OGC Specification"},{"location":"#postgispostgres","text":"TiFeatures rely a lot of ST_* PostGIS functions. You need to make sure your Postgres database has Postgis installed. SELECT name , default_version , installed_version FROM pg_available_extensions WHERE name LIKE 'postgis%' or name LIKE 'address%' ; CREATE EXTENSION postgis ;","title":"PostGIS/Postgres"},{"location":"#configuration","text":"To be able to work, the application will need access to the database. tifeatures uses starlette 's configuration pattern which make use of environment variable and/or .env file to pass variable to the application. Example of .env file can be found in .env.example # you need define the DATABASE_URL directly DATABASE_URL=postgresql://username:password@0.0.0.0:5432/postgis","title":"Configuration"},{"location":"#launch","text":"$ pip install uvicorn # Set your postgis database instance URL in the environment $ export DATABASE_URL = postgresql://username:password@0.0.0.0:5432/postgis $ uvicorn tifeatures.main:app # or using Docker $ docker-compose up","title":"Launch"},{"location":"#contribution-development","text":"See CONTRIBUTING.md","title":"Contribution &amp; Development"},{"location":"#license","text":"See LICENSE","title":"License"},{"location":"#authors","text":"Created by Development Seed","title":"Authors"},{"location":"#changes","text":"See CHANGES.md .","title":"Changes"},{"location":"contributing/","text":"Development - Contributing \u00b6 Issues and pull requests are more than welcome: github.com/developmentseed/tifeatures/issues dev install $ git clone https://github.com/developmentseed/tifeatures.git $ cd tifeatures $ pip install -e . [ \"test,dev\" ] You can then run the tests with the following command: python -m pytest --cov tifeatures --cov-report term-missing --asyncio-mode = strict and run benchmark python -m pytest tests/benchmarks.py --benchmark-only --benchmark-columns 'min, max, mean, median' --asyncio-mode = strict pre-commit This repo is set to use pre-commit to run isort , flake8 , pydocstring , black (\"uncompromising Python code formatter\") and mypy when committing new code. # Install pre-commit command $ pip install pre-commit # Setup pre-commit withing your local environment $ pre-commit install","title":"Development - Contributing"},{"location":"contributing/#development-contributing","text":"Issues and pull requests are more than welcome: github.com/developmentseed/tifeatures/issues dev install $ git clone https://github.com/developmentseed/tifeatures.git $ cd tifeatures $ pip install -e . [ \"test,dev\" ] You can then run the tests with the following command: python -m pytest --cov tifeatures --cov-report term-missing --asyncio-mode = strict and run benchmark python -m pytest tests/benchmarks.py --benchmark-only --benchmark-columns 'min, max, mean, median' --asyncio-mode = strict pre-commit This repo is set to use pre-commit to run isort , flake8 , pydocstring , black (\"uncompromising Python code formatter\") and mypy when committing new code. # Install pre-commit command $ pip install pre-commit # Setup pre-commit withing your local environment $ pre-commit install","title":"Development - Contributing"},{"location":"endpoints/","text":"Landing page \u00b6 Path: / QueryParams: f (str, one of [ json , html ]): Select response MediaType. HeaderParams: accept (str, one of [ application/json , text/html ]): Select response MediaType. Example: curl h tt p : //127.0.0.1:8081 | jq { \"title\" : \"TiFeatures\" , \"links\" : [ { \"href\" : \"http://127.0.0.1:8081/\" , \"rel\" : \"self\" , \"type\" : \"application/json\" , \"title\" : \"Landing Page\" }, { \"href\" : \"http://127.0.0.1:8081/api\" , \"rel\" : \"service-desc\" , \"type\" : \"application/vnd.oai.openapi+json;version=3.0\" , \"title\" : \"the API definition (JSON)\" }, { \"href\" : \"http://127.0.0.1:8081/api.html\" , \"rel\" : \"service-doc\" , \"type\" : \"text/html\" , \"title\" : \"the API documentation\" }, { \"href\" : \"http://127.0.0.1:8081/conformance\" , \"rel\" : \"conformance\" , \"type\" : \"application/json\" , \"title\" : \"Conformance\" }, { \"href\" : \"http://127.0.0.1:8081/collections\" , \"rel\" : \"data\" , \"type\" : \"application/json\" , \"title\" : \"List of Collections\" }, { \"href\" : \"http://127.0.0.1:8081/collections/{collectionId}\" , \"rel\" : \"data\" , \"type\" : \"application/json\" , \"title\" : \"Collection metadata\" }, { \"href\" : \"http://127.0.0.1:8081/collections/{collectionId}/queryables\" , \"rel\" : \"queryables\" , \"type\" : \"application/schema+json\" , \"title\" : \"Collection queryables\" }, { \"href\" : \"http://127.0.0.1:8081/collections/{collectionId}/items\" , \"rel\" : \"data\" , \"type\" : \"application/geo+json\" , \"title\" : \"Collection Features\" }, { \"href\" : \"http://127.0.0.1:8081/collections/{collectionId}/items/{itemId}\" , \"rel\" : \"data\" , \"type\" : \"application/geo+json\" , \"title\" : \"Collection Feature\" } ] } Ref: docs.ogc.org/is/17-069r4/17-069r4.html#_api_landing_page Conformance declaration \u00b6 Path: /conformance QueryParams: f (str, one of [ json , html ]): Select response MediaType. HeaderParams: accept (str, one of [ application/json , text/html ])): Select response MediaType. Example: curl h tt p : //127.0.0.1:8081/conformance | jq { \"conformsTo\" : [ \"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/core\" , \"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/oas3\" , \"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/geojson\" , \"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/html\" , \"http://www.opengis.net/spec/ogcapi-common-1/1.0/conf/core\" , \"http://www.opengis.net/spec/ogcapi-common-1/1.0/conf/landing-page\" , \"http://www.opengis.net/spec/ogcapi-common-1/1.0/conf/json\" , \"http://www.opengis.net/spec/ogcapi-common-1/1.0/conf/html\" , \"http://www.opengis.net/spec/ogcapi-common-1/1.0/conf/oas30\" , \"http://www.opengis.net/spec/ogcapi-common-2/1.0/conf/collections\" , \"http://www.opengis.net/spec/ogcapi-common-2/1.0/conf/simple-query\" , \"http://www.opengis.net/spec/ogcapi-features-3/1.0/conf/filter,\" , \"http://www.opengis.net/def/rel/ogc/1.0/queryables\" ] } Ref: docs.ogc.org/is/17-069r4/17-069r4.html#_declaration_of_conformance_classes List Feature Collections \u00b6 Path: /collections QueryParams: f (str, one of [ json , html ]): Select response MediaType. HeaderParams: accept (str, one of [ application/json , text/html ])): Select response MediaType. Example: curl h tt p : //127.0.0.1:8081/collections | jq { \"collections\" : [ { \"id\" : \"public.countries\" , \"title\" : \"public.countries\" , \"links\" : [ { \"href\" : \"http://127.0.0.1:8081/collections/public.countries\" , \"rel\" : \"collection\" , \"type\" : \"application/json\" }, { \"href\" : \"http://127.0.0.1:8081/collections/public.countries/items\" , \"rel\" : \"items\" , \"type\" : \"application/geo+json\" }, { \"href\" : \"http://127.0.0.1:8081/collections/public.countries/queryables\" , \"rel\" : \"queryables\" , \"type\" : \"application/schema+json\" } ], \"itemType\" : \"feature\" , \"crs\" : [ \"http://www.opengis.net/def/crs/OGC/1.3/CRS84\" ] }, ... ], \"links\" : [ { \"href\" : \"http://127.0.0.1:8081/\" , \"rel\" : \"parent\" , \"type\" : \"application/json\" }, { \"href\" : \"http://127.0.0.1:8081/collections\" , \"rel\" : \"self\" , \"type\" : \"application/json\" } ] } Ref: docs.ogc.org/is/17-069r4/17-069r4.html#_collections _ Feature Collection's Metadata \u00b6 Path: /collections/{collectionId} PathParams: collectionId (str): Feature Collection Id QueryParams: f (str, one of [ json , html ]): Select response MediaType. HeaderParams: accept (str, one of [ application/json , text/html ])): Select response MediaType. Example: curl h tt p : //127.0.0.1:8081/collections/public.countries | jq { \"id\" : \"public.countries\" , \"links\" : [ { \"href\" : \"http://127.0.0.1:8081/collections/public.countries\" , \"rel\" : \"self\" , \"type\" : \"application/json\" }, { \"href\" : \"http://127.0.0.1:8081/collections/public.countries/items\" , \"rel\" : \"items\" , \"type\" : \"application/geo+json\" , \"title\" : \"Items\" }, { \"href\" : \"http://127.0.0.1:8081/collections/public.countries/items?f=csv\" , \"rel\" : \"alternate\" , \"type\" : \"text/csv\" , \"title\" : \"Items (CSV)\" }, { \"href\" : \"http://127.0.0.1:8081/collections/public.countries/items?f=geojsonseq\" , \"rel\" : \"alternate\" , \"type\" : \"application/geo+json-seq\" , \"title\" : \"Items (GeoJSONSeq)\" }, { \"href\" : \"http://127.0.0.1:8081/collections/public.countries/queryables\" , \"rel\" : \"queryables\" , \"type\" : \"application/schema+json\" , \"title\" : \"Queryables\" } ], \"itemType\" : \"feature\" , \"crs\" : [ \"http://www.opengis.net/def/crs/OGC/1.3/CRS84\" ] } Ref: docs.ogc.org/is/17-069r4/17-069r4.html#_collection _ Feature Collection's Queryables \u00b6 Path: /collections/{collectionId}/queryables PathParams: collectionId (str): Feature Collection Id QueryParams: f (str, one of [ json , html ]): Select response MediaType. HeaderParams: accept (str, one of [ application/json , text/html ])): Select response MediaType. Example: curl h tt p : //127.0.0.1:8081/collections/public.landsat_wrs/queryables | jq { \"title\" : \"public.landsat_wrs\" , \"properties\" : { \"geom\" : { \"$ref\" : \"https://geojson.org/schema/Geometry.json\" }, \"ogc_fid\" : { \"name\" : \"ogc_fid\" , \"type\" : \"number\" }, \"id\" : { \"name\" : \"id\" , \"type\" : \"string\" }, \"pr\" : { \"name\" : \"pr\" , \"type\" : \"string\" }, \"path\" : { \"name\" : \"path\" , \"type\" : \"number\" }, \"row\" : { \"name\" : \"row\" , \"type\" : \"number\" } }, \"type\" : \"object\" , \"$schema\" : \"https://json-schema.org/draft/2019-09/schema\" , \"$id\" : \"http://127.0.0.1:8081/collections/public.landsat_wrs/queryables\" } Ref: docs.ogc.org/DRAFTS/19-079r1.html#filter-queryables Features \u00b6 Path: /collections/{collectionId}/items PathParams: collectionId (str): Feature Collection Id QueryParams: limit (int): Limits the number of features in the response. Defaults to 10. offset (int): Features offset. bbox (str): Coma (,) delimited bbox coordinates to spatially filter features in minx,miny,maxx,maxy form. datetime (str): Single datetime or / delimited datetime intervals to temporally filter features. interval-bounded = date-time/date-time interval-half-bounded-start = ../date-time interval-half-bounded-end = date-time/.. datetime = date-time ids * (str): Coma (,) delimited list of item Ids. properties * (str): Coma (,) delimited list of item properties to return in each feature. filter (str): CQL2 filter as defined by docs.ogc.org/DRAFTS/19-079r1.html#rc_filter filter-lang (str, one of [ cql2-text , cql2-json ]): Filter language. Defaults to cql2-text . geom-column * (str): Select geometry column to apply filter on and to create geometry from. datetime-column * (str): Select datetime column to apply filter on. bbox-only * (bool): Only return the bounding box of the feature. simplify * (float): Simplify the output geometry to given threshold in decimal degrees. f (str, one of [ geojson , html , json , csv , geojsonseq , ndjson ]): Select response MediaType. HeaderParams: accept (str, one of [ application/geo+json , text/html , application/json , text/csv , application/geo+json-seq , application/ndjson ])): Select response MediaType. * Not in OGC API Features Specification Important Additional query-parameters (form PROP=VALUE ) will be considered as a property filter . Properties ( PROP ) not matching collection's column will be ignored. Example: http://127.0.0.1:8081/collections/public.countries/items http://127.0.0.1:8081/collections/public.countries/items?limit=1 limit to only 1 feature http://127.0.0.1:8081/collections/public.countries/items?limit=1&offset=2 limit to only 1 feature and add offset 2 (return the third feature of the collection) http://127.0.0.1:8081/collections/public.countries/items?bbox=-94.702148,34.488448,-85.429688,41.112469 limit result to a specific bbox . http://127.0.0.1:8081/collections/public.countries/items?ids=1,2,3 limit result to ids 1 , 2 and 3 http://127.0.0.1:8081/collections/public.countries/items?properties=name only return name property Property Filter http://127.0.0.1:8081/collections/public.countries/items?name=Zimbabwe only return features where property name==Zimbabwe Datetime http://127.0.0.1:8081/collections/public.countries/items?datetime=2004-10-19T10:23:54Z return features with datetime column with value ==2004-10-19T10:23:54Z . http://127.0.0.1:8081/collections/public.countries/items?datetime=../2004-10-19T10:23:54Z return features with datetime column with value <=2004-10-19T10:23:54Z . http://127.0.0.1:8081/collections/public.countries/items?datetime=2004-10-19T10:23:54Z/.. return features with datetime column with value >=2004-10-19T10:23:54Z . http://127.0.0.1:8081/collections/public.countries/items?datetime=2004-10-19T10:23:54Z/2004-10-20T10:23:54Z return features with datetime column with value between 2004-10-19T10:23:54Z and 2004-10-20T10:23:54Z . CQL2 http://127.0.0.1:8081/collections/public.countries/items?filter-lang=cql2-json&filter={\"op\":\"=\",\"args\":[{\"property\":\"ogc_fid\"},1]} http://127.0.0.1:8081/collections/public.countries/items?filter-lang=cql2-text&filter=ogc_fid=1 Ref: docs.ogc.org/is/17-069r4/17-069r4.html#_items _ and docs.ogc.org/DRAFTS/19-079r1.html#filter-param Feature \u00b6 Path: /collections/{collectionId}/items/{itemId} PathParams: collectionId (str): Feature Collection Id itemId (str): Feature Id QueryParams: - geom-column * (str): Select geometry column to create geometry from. - bbox-only * (bool): Only return the bounding box of the feature. - simplify * (float): Simplify the output geometry to given threshold in decimal degrees. f (str, one of [ geojson , html , json ]): Select response MediaType. HeaderParams: accept (str, one of [ application/geo+json , text/html , application/json ])): Select response MediaType. Example: { \"type\" : \"Feature\" , \"geometry\" : { \"coordinates\" : [ ... ] \"type\" : \"MultiPolygon\" }, \"properties\" : { \"gid\" : 1 , \"name\" : \"Zimbabwe\" , ... }, \"id\" : \"1\" , \"links\" : [ { \"href\" : \"http://127.0.0.1:8081/collections/public.countries\" , \"rel\" : \"collection\" , \"type\" : \"application/json\" }, { \"href\" : \"http://127.0.0.1:8081/collections/public.countries/items/1\" , \"rel\" : \"self\" , \"type\" : \"application/geo+json\" } ] } Ref: docs.ogc.org/is/17-069r4/17-069r4.html#_feature _","title":"Endpoints"},{"location":"endpoints/#landing-page","text":"Path: / QueryParams: f (str, one of [ json , html ]): Select response MediaType. HeaderParams: accept (str, one of [ application/json , text/html ]): Select response MediaType. Example: curl h tt p : //127.0.0.1:8081 | jq { \"title\" : \"TiFeatures\" , \"links\" : [ { \"href\" : \"http://127.0.0.1:8081/\" , \"rel\" : \"self\" , \"type\" : \"application/json\" , \"title\" : \"Landing Page\" }, { \"href\" : \"http://127.0.0.1:8081/api\" , \"rel\" : \"service-desc\" , \"type\" : \"application/vnd.oai.openapi+json;version=3.0\" , \"title\" : \"the API definition (JSON)\" }, { \"href\" : \"http://127.0.0.1:8081/api.html\" , \"rel\" : \"service-doc\" , \"type\" : \"text/html\" , \"title\" : \"the API documentation\" }, { \"href\" : \"http://127.0.0.1:8081/conformance\" , \"rel\" : \"conformance\" , \"type\" : \"application/json\" , \"title\" : \"Conformance\" }, { \"href\" : \"http://127.0.0.1:8081/collections\" , \"rel\" : \"data\" , \"type\" : \"application/json\" , \"title\" : \"List of Collections\" }, { \"href\" : \"http://127.0.0.1:8081/collections/{collectionId}\" , \"rel\" : \"data\" , \"type\" : \"application/json\" , \"title\" : \"Collection metadata\" }, { \"href\" : \"http://127.0.0.1:8081/collections/{collectionId}/queryables\" , \"rel\" : \"queryables\" , \"type\" : \"application/schema+json\" , \"title\" : \"Collection queryables\" }, { \"href\" : \"http://127.0.0.1:8081/collections/{collectionId}/items\" , \"rel\" : \"data\" , \"type\" : \"application/geo+json\" , \"title\" : \"Collection Features\" }, { \"href\" : \"http://127.0.0.1:8081/collections/{collectionId}/items/{itemId}\" , \"rel\" : \"data\" , \"type\" : \"application/geo+json\" , \"title\" : \"Collection Feature\" } ] } Ref: docs.ogc.org/is/17-069r4/17-069r4.html#_api_landing_page","title":"Landing page"},{"location":"endpoints/#conformance-declaration","text":"Path: /conformance QueryParams: f (str, one of [ json , html ]): Select response MediaType. HeaderParams: accept (str, one of [ application/json , text/html ])): Select response MediaType. Example: curl h tt p : //127.0.0.1:8081/conformance | jq { \"conformsTo\" : [ \"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/core\" , \"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/oas3\" , \"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/geojson\" , \"http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/html\" , \"http://www.opengis.net/spec/ogcapi-common-1/1.0/conf/core\" , \"http://www.opengis.net/spec/ogcapi-common-1/1.0/conf/landing-page\" , \"http://www.opengis.net/spec/ogcapi-common-1/1.0/conf/json\" , \"http://www.opengis.net/spec/ogcapi-common-1/1.0/conf/html\" , \"http://www.opengis.net/spec/ogcapi-common-1/1.0/conf/oas30\" , \"http://www.opengis.net/spec/ogcapi-common-2/1.0/conf/collections\" , \"http://www.opengis.net/spec/ogcapi-common-2/1.0/conf/simple-query\" , \"http://www.opengis.net/spec/ogcapi-features-3/1.0/conf/filter,\" , \"http://www.opengis.net/def/rel/ogc/1.0/queryables\" ] } Ref: docs.ogc.org/is/17-069r4/17-069r4.html#_declaration_of_conformance_classes","title":"Conformance declaration"},{"location":"endpoints/#list-feature-collections","text":"Path: /collections QueryParams: f (str, one of [ json , html ]): Select response MediaType. HeaderParams: accept (str, one of [ application/json , text/html ])): Select response MediaType. Example: curl h tt p : //127.0.0.1:8081/collections | jq { \"collections\" : [ { \"id\" : \"public.countries\" , \"title\" : \"public.countries\" , \"links\" : [ { \"href\" : \"http://127.0.0.1:8081/collections/public.countries\" , \"rel\" : \"collection\" , \"type\" : \"application/json\" }, { \"href\" : \"http://127.0.0.1:8081/collections/public.countries/items\" , \"rel\" : \"items\" , \"type\" : \"application/geo+json\" }, { \"href\" : \"http://127.0.0.1:8081/collections/public.countries/queryables\" , \"rel\" : \"queryables\" , \"type\" : \"application/schema+json\" } ], \"itemType\" : \"feature\" , \"crs\" : [ \"http://www.opengis.net/def/crs/OGC/1.3/CRS84\" ] }, ... ], \"links\" : [ { \"href\" : \"http://127.0.0.1:8081/\" , \"rel\" : \"parent\" , \"type\" : \"application/json\" }, { \"href\" : \"http://127.0.0.1:8081/collections\" , \"rel\" : \"self\" , \"type\" : \"application/json\" } ] } Ref: docs.ogc.org/is/17-069r4/17-069r4.html#_collections _","title":"List Feature Collections"},{"location":"endpoints/#feature-collections-metadata","text":"Path: /collections/{collectionId} PathParams: collectionId (str): Feature Collection Id QueryParams: f (str, one of [ json , html ]): Select response MediaType. HeaderParams: accept (str, one of [ application/json , text/html ])): Select response MediaType. Example: curl h tt p : //127.0.0.1:8081/collections/public.countries | jq { \"id\" : \"public.countries\" , \"links\" : [ { \"href\" : \"http://127.0.0.1:8081/collections/public.countries\" , \"rel\" : \"self\" , \"type\" : \"application/json\" }, { \"href\" : \"http://127.0.0.1:8081/collections/public.countries/items\" , \"rel\" : \"items\" , \"type\" : \"application/geo+json\" , \"title\" : \"Items\" }, { \"href\" : \"http://127.0.0.1:8081/collections/public.countries/items?f=csv\" , \"rel\" : \"alternate\" , \"type\" : \"text/csv\" , \"title\" : \"Items (CSV)\" }, { \"href\" : \"http://127.0.0.1:8081/collections/public.countries/items?f=geojsonseq\" , \"rel\" : \"alternate\" , \"type\" : \"application/geo+json-seq\" , \"title\" : \"Items (GeoJSONSeq)\" }, { \"href\" : \"http://127.0.0.1:8081/collections/public.countries/queryables\" , \"rel\" : \"queryables\" , \"type\" : \"application/schema+json\" , \"title\" : \"Queryables\" } ], \"itemType\" : \"feature\" , \"crs\" : [ \"http://www.opengis.net/def/crs/OGC/1.3/CRS84\" ] } Ref: docs.ogc.org/is/17-069r4/17-069r4.html#_collection _","title":"Feature Collection's Metadata"},{"location":"endpoints/#feature-collections-queryables","text":"Path: /collections/{collectionId}/queryables PathParams: collectionId (str): Feature Collection Id QueryParams: f (str, one of [ json , html ]): Select response MediaType. HeaderParams: accept (str, one of [ application/json , text/html ])): Select response MediaType. Example: curl h tt p : //127.0.0.1:8081/collections/public.landsat_wrs/queryables | jq { \"title\" : \"public.landsat_wrs\" , \"properties\" : { \"geom\" : { \"$ref\" : \"https://geojson.org/schema/Geometry.json\" }, \"ogc_fid\" : { \"name\" : \"ogc_fid\" , \"type\" : \"number\" }, \"id\" : { \"name\" : \"id\" , \"type\" : \"string\" }, \"pr\" : { \"name\" : \"pr\" , \"type\" : \"string\" }, \"path\" : { \"name\" : \"path\" , \"type\" : \"number\" }, \"row\" : { \"name\" : \"row\" , \"type\" : \"number\" } }, \"type\" : \"object\" , \"$schema\" : \"https://json-schema.org/draft/2019-09/schema\" , \"$id\" : \"http://127.0.0.1:8081/collections/public.landsat_wrs/queryables\" } Ref: docs.ogc.org/DRAFTS/19-079r1.html#filter-queryables","title":"Feature Collection's Queryables"},{"location":"endpoints/#features","text":"Path: /collections/{collectionId}/items PathParams: collectionId (str): Feature Collection Id QueryParams: limit (int): Limits the number of features in the response. Defaults to 10. offset (int): Features offset. bbox (str): Coma (,) delimited bbox coordinates to spatially filter features in minx,miny,maxx,maxy form. datetime (str): Single datetime or / delimited datetime intervals to temporally filter features. interval-bounded = date-time/date-time interval-half-bounded-start = ../date-time interval-half-bounded-end = date-time/.. datetime = date-time ids * (str): Coma (,) delimited list of item Ids. properties * (str): Coma (,) delimited list of item properties to return in each feature. filter (str): CQL2 filter as defined by docs.ogc.org/DRAFTS/19-079r1.html#rc_filter filter-lang (str, one of [ cql2-text , cql2-json ]): Filter language. Defaults to cql2-text . geom-column * (str): Select geometry column to apply filter on and to create geometry from. datetime-column * (str): Select datetime column to apply filter on. bbox-only * (bool): Only return the bounding box of the feature. simplify * (float): Simplify the output geometry to given threshold in decimal degrees. f (str, one of [ geojson , html , json , csv , geojsonseq , ndjson ]): Select response MediaType. HeaderParams: accept (str, one of [ application/geo+json , text/html , application/json , text/csv , application/geo+json-seq , application/ndjson ])): Select response MediaType. * Not in OGC API Features Specification Important Additional query-parameters (form PROP=VALUE ) will be considered as a property filter . Properties ( PROP ) not matching collection's column will be ignored. Example: http://127.0.0.1:8081/collections/public.countries/items http://127.0.0.1:8081/collections/public.countries/items?limit=1 limit to only 1 feature http://127.0.0.1:8081/collections/public.countries/items?limit=1&offset=2 limit to only 1 feature and add offset 2 (return the third feature of the collection) http://127.0.0.1:8081/collections/public.countries/items?bbox=-94.702148,34.488448,-85.429688,41.112469 limit result to a specific bbox . http://127.0.0.1:8081/collections/public.countries/items?ids=1,2,3 limit result to ids 1 , 2 and 3 http://127.0.0.1:8081/collections/public.countries/items?properties=name only return name property Property Filter http://127.0.0.1:8081/collections/public.countries/items?name=Zimbabwe only return features where property name==Zimbabwe Datetime http://127.0.0.1:8081/collections/public.countries/items?datetime=2004-10-19T10:23:54Z return features with datetime column with value ==2004-10-19T10:23:54Z . http://127.0.0.1:8081/collections/public.countries/items?datetime=../2004-10-19T10:23:54Z return features with datetime column with value <=2004-10-19T10:23:54Z . http://127.0.0.1:8081/collections/public.countries/items?datetime=2004-10-19T10:23:54Z/.. return features with datetime column with value >=2004-10-19T10:23:54Z . http://127.0.0.1:8081/collections/public.countries/items?datetime=2004-10-19T10:23:54Z/2004-10-20T10:23:54Z return features with datetime column with value between 2004-10-19T10:23:54Z and 2004-10-20T10:23:54Z . CQL2 http://127.0.0.1:8081/collections/public.countries/items?filter-lang=cql2-json&filter={\"op\":\"=\",\"args\":[{\"property\":\"ogc_fid\"},1]} http://127.0.0.1:8081/collections/public.countries/items?filter-lang=cql2-text&filter=ogc_fid=1 Ref: docs.ogc.org/is/17-069r4/17-069r4.html#_items _ and docs.ogc.org/DRAFTS/19-079r1.html#filter-param","title":"Features"},{"location":"endpoints/#feature","text":"Path: /collections/{collectionId}/items/{itemId} PathParams: collectionId (str): Feature Collection Id itemId (str): Feature Id QueryParams: - geom-column * (str): Select geometry column to create geometry from. - bbox-only * (bool): Only return the bounding box of the feature. - simplify * (float): Simplify the output geometry to given threshold in decimal degrees. f (str, one of [ geojson , html , json ]): Select response MediaType. HeaderParams: accept (str, one of [ application/geo+json , text/html , application/json ])): Select response MediaType. Example: { \"type\" : \"Feature\" , \"geometry\" : { \"coordinates\" : [ ... ] \"type\" : \"MultiPolygon\" }, \"properties\" : { \"gid\" : 1 , \"name\" : \"Zimbabwe\" , ... }, \"id\" : \"1\" , \"links\" : [ { \"href\" : \"http://127.0.0.1:8081/collections/public.countries\" , \"rel\" : \"collection\" , \"type\" : \"application/json\" }, { \"href\" : \"http://127.0.0.1:8081/collections/public.countries/items/1\" , \"rel\" : \"self\" , \"type\" : \"application/geo+json\" } ] } Ref: docs.ogc.org/is/17-069r4/17-069r4.html#_feature _","title":"Feature"},{"location":"release-notes/","text":"Release Notes \u00b6 0.1.0a1 (2022-11-16) \u00b6 fix package metadata 0.1.0a0 (2022-11-16) \u00b6 OGC Feature API Part 1: Core ( docs.ogc.org/is/17-069r4/17-069r4.html ) OGC Feature API Part 3: Filtering / CQL2 ( docs.ogc.org/DRAFTS/19-079r1.html ) Support multiple output format (json, html, geojson, ndjson, csv, geojson-seg) geometry column selection datetime column selection primary key column selection output property filter options to reduce the bandwidth required for returning record geometries. bbox-only=[bool] only return the bounding box in the return geometry geom-column=none don't return geometry as part of the return simplify=[float] Use ST_SnapToGrid(ST_Simplify(geom, [simplify]),[simplify]) to simplify and reduce precision of output geometry. sortby=[\u00b1][field] support to sorting by a field ability to use user defined PostgreSQL functions as per the \"custom functions\" spec in CQL2.","title":"Release Notes"},{"location":"release-notes/#release-notes","text":"","title":"Release Notes"},{"location":"release-notes/#010a1-2022-11-16","text":"fix package metadata","title":"0.1.0a1 (2022-11-16)"},{"location":"release-notes/#010a0-2022-11-16","text":"OGC Feature API Part 1: Core ( docs.ogc.org/is/17-069r4/17-069r4.html ) OGC Feature API Part 3: Filtering / CQL2 ( docs.ogc.org/DRAFTS/19-079r1.html ) Support multiple output format (json, html, geojson, ndjson, csv, geojson-seg) geometry column selection datetime column selection primary key column selection output property filter options to reduce the bandwidth required for returning record geometries. bbox-only=[bool] only return the bounding box in the return geometry geom-column=none don't return geometry as part of the return simplify=[float] Use ST_SnapToGrid(ST_Simplify(geom, [simplify]),[simplify]) to simplify and reduce precision of output geometry. sortby=[\u00b1][field] support to sorting by a field ability to use user defined PostgreSQL functions as per the \"custom functions\" spec in CQL2.","title":"0.1.0a0 (2022-11-16)"},{"location":"advanced/timvt_and_tifeatures/","text":"TiFeatures and TiMVT share a lot of in common and it's possible to create a unique FastAPI application with both Features and MVT endpoints: \"\"\"Features and MVT app.\"\"\" from tifeatures.db import close_db_connection , connect_to_db , register_table_catalog from tifeatures.factory import Endpoints from timvt.factory import VectorTilerFactory from fastapi import FastAPI from starlette_cramjam.middleware import CompressionMiddleware app = FastAPI ( title = \"Features and MVT\" , openapi_url = \"/api\" , docs_url = \"/api.html\" , ) # Register endpoints. endpoints = Endpoints () app . include_router ( endpoints . router , tags = [ \"Features\" ]) # By default the VectorTilerFactory will only create tiles/ and tilejson.json endpoints mvt_endpoints = VectorTilerFactory () app . include_router ( mvt_endpoints . router ) app . add_middleware ( CompressionMiddleware ) @app . on_event ( \"startup\" ) async def startup_event () -> None : \"\"\"Connect to database on startup.\"\"\" await connect_to_db ( app ) # TiMVT and TiFeatures share the same `Table_catalog` format # see https://github.com/developmentseed/timvt/pull/83 await register_table_catalog ( app ) @app . on_event ( \"shutdown\" ) async def shutdown_event () -> None : \"\"\"Close database connection.\"\"\" await close_db_connection ( app ) Note To run the example, copy the code to a file main.py, and start uvicorn with: uvicorn main:app --reload","title":"Combine MVT and Features"},{"location":"api/tifeatures/db/","text":"Module tifeatures.db \u00b6 tifeatures.db: database events. None Functions \u00b6 close_db_connection \u00b6 def close_db_connection ( app : fastapi . applications . FastAPI ) -> None Close connection. con_init \u00b6 def con_init ( conn ) Use json for json returns. connect_to_db \u00b6 def connect_to_db ( app : fastapi . applications . FastAPI , settings : Union [ tifeatures . settings . PostgresSettings , NoneType ] = None , ** kwargs ) -> None Connect. register_table_catalog \u00b6 def register_table_catalog ( app : fastapi . applications . FastAPI , ** kwargs : Any ) -> None Register Table catalog.","title":"db"},{"location":"api/tifeatures/db/#module-tifeaturesdb","text":"tifeatures.db: database events. None","title":"Module tifeatures.db"},{"location":"api/tifeatures/db/#functions","text":"","title":"Functions"},{"location":"api/tifeatures/db/#close_db_connection","text":"def close_db_connection ( app : fastapi . applications . FastAPI ) -> None Close connection.","title":"close_db_connection"},{"location":"api/tifeatures/db/#con_init","text":"def con_init ( conn ) Use json for json returns.","title":"con_init"},{"location":"api/tifeatures/db/#connect_to_db","text":"def connect_to_db ( app : fastapi . applications . FastAPI , settings : Union [ tifeatures . settings . PostgresSettings , NoneType ] = None , ** kwargs ) -> None Connect.","title":"connect_to_db"},{"location":"api/tifeatures/db/#register_table_catalog","text":"def register_table_catalog ( app : fastapi . applications . FastAPI , ** kwargs : Any ) -> None Register Table catalog.","title":"register_table_catalog"},{"location":"api/tifeatures/dbmodel/","text":"Module tifeatures.dbmodel \u00b6 tifeatures.dbmodel: database events. None Variables \u00b6 Database Functions \u00b6 get_table_index \u00b6 def get_table_index ( db_pool : buildpg . asyncpg . BuildPgPool , schemas : Union [ List [ str ], NoneType ] = [ 'public' ], tables : Union [ List [ str ], NoneType ] = None , spatial : bool = True ) -> Dict [ str , Dict [ str , Any ]] Fetch Table index. Classes \u00b6 Column \u00b6 class Column ( __pydantic_self__ , ** data : Any ) Ancestors (in MRO) \u00b6 pydantic.main.BaseModel pydantic.utils.Representation Descendants \u00b6 tifeatures.dbmodel.GeometryColumn tifeatures.dbmodel.DatetimeColumn Class variables \u00b6 Config Static methods \u00b6 construct \u00b6 def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm \u00b6 def from_orm ( obj : Any ) -> 'Model' parse_file \u00b6 def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj \u00b6 def parse_obj ( obj : Any ) -> 'Model' parse_raw \u00b6 def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema \u00b6 def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json \u00b6 def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs \u00b6 def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate \u00b6 def validate ( value : Any ) -> 'Model' Instance variables \u00b6 json_type Return JSON field type. Methods \u00b6 copy \u00b6 def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict \u00b6 def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json \u00b6 def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . DatetimeColumn \u00b6 class DatetimeColumn ( __pydantic_self__ , ** data : Any ) Ancestors (in MRO) \u00b6 tifeatures.dbmodel.Column pydantic.main.BaseModel pydantic.utils.Representation Class variables \u00b6 Config Static methods \u00b6 construct \u00b6 def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm \u00b6 def from_orm ( obj : Any ) -> 'Model' parse_file \u00b6 def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj \u00b6 def parse_obj ( obj : Any ) -> 'Model' parse_raw \u00b6 def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema \u00b6 def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json \u00b6 def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs \u00b6 def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate \u00b6 def validate ( value : Any ) -> 'Model' Instance variables \u00b6 json_type Return JSON field type. Methods \u00b6 copy \u00b6 def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict \u00b6 def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json \u00b6 def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . GeometryColumn \u00b6 class GeometryColumn ( __pydantic_self__ , ** data : Any ) Ancestors (in MRO) \u00b6 tifeatures.dbmodel.Column pydantic.main.BaseModel pydantic.utils.Representation Class variables \u00b6 Config Static methods \u00b6 construct \u00b6 def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm \u00b6 def from_orm ( obj : Any ) -> 'Model' parse_file \u00b6 def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj \u00b6 def parse_obj ( obj : Any ) -> 'Model' parse_raw \u00b6 def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema \u00b6 def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json \u00b6 def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs \u00b6 def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate \u00b6 def validate ( value : Any ) -> 'Model' Instance variables \u00b6 json_type Return JSON field type. Methods \u00b6 copy \u00b6 def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict \u00b6 def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json \u00b6 def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Table \u00b6 class Table ( __pydantic_self__ , ** data : Any ) Ancestors (in MRO) \u00b6 pydantic.main.BaseModel pydantic.utils.Representation Descendants \u00b6 tifeatures.layer.Table Class variables \u00b6 Config Static methods \u00b6 construct \u00b6 def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm \u00b6 def from_orm ( obj : Any ) -> 'Model' parse_file \u00b6 def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj \u00b6 def parse_obj ( obj : Any ) -> 'Model' parse_raw \u00b6 def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema \u00b6 def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json \u00b6 def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs \u00b6 def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate \u00b6 def validate ( value : Any ) -> 'Model' Instance variables \u00b6 id_column_info Return Column for a unique identifier. Methods \u00b6 columns \u00b6 def columns ( self , properties : Union [ List [ str ], NoneType ] = None ) -> List [ str ] Return table columns optionally filtered to only include columns from properties. copy \u00b6 def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict \u00b6 def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. get_column \u00b6 def get_column ( self , property_name : str ) -> Union [ tifeatures . dbmodel . Column , NoneType ] Return column info. get_datetime_column \u00b6 def get_datetime_column ( self , name : Union [ str , NoneType ] = None ) -> Union [ tifeatures . dbmodel . Column , NoneType ] Return the Column for either the passed in tstz column or the first tstz column. get_geometry_column \u00b6 def get_geometry_column ( self , name : Union [ str , NoneType ] = None ) -> Union [ tifeatures . dbmodel . GeometryColumn , NoneType ] Return the name of the first geometry column. json \u00b6 def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"dbmodel"},{"location":"api/tifeatures/dbmodel/#module-tifeaturesdbmodel","text":"tifeatures.dbmodel: database events. None","title":"Module tifeatures.dbmodel"},{"location":"api/tifeatures/dbmodel/#variables","text":"Database","title":"Variables"},{"location":"api/tifeatures/dbmodel/#functions","text":"","title":"Functions"},{"location":"api/tifeatures/dbmodel/#get_table_index","text":"def get_table_index ( db_pool : buildpg . asyncpg . BuildPgPool , schemas : Union [ List [ str ], NoneType ] = [ 'public' ], tables : Union [ List [ str ], NoneType ] = None , spatial : bool = True ) -> Dict [ str , Dict [ str , Any ]] Fetch Table index.","title":"get_table_index"},{"location":"api/tifeatures/dbmodel/#classes","text":"","title":"Classes"},{"location":"api/tifeatures/dbmodel/#column","text":"class Column ( __pydantic_self__ , ** data : Any )","title":"Column"},{"location":"api/tifeatures/dbmodel/#ancestors-in-mro","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/dbmodel/#descendants","text":"tifeatures.dbmodel.GeometryColumn tifeatures.dbmodel.DatetimeColumn","title":"Descendants"},{"location":"api/tifeatures/dbmodel/#class-variables","text":"Config","title":"Class variables"},{"location":"api/tifeatures/dbmodel/#static-methods","text":"","title":"Static methods"},{"location":"api/tifeatures/dbmodel/#construct","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"api/tifeatures/dbmodel/#from_orm","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"api/tifeatures/dbmodel/#parse_file","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"api/tifeatures/dbmodel/#parse_obj","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"api/tifeatures/dbmodel/#parse_raw","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"api/tifeatures/dbmodel/#schema","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"api/tifeatures/dbmodel/#schema_json","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"api/tifeatures/dbmodel/#update_forward_refs","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"api/tifeatures/dbmodel/#validate","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"api/tifeatures/dbmodel/#instance-variables","text":"json_type Return JSON field type.","title":"Instance variables"},{"location":"api/tifeatures/dbmodel/#methods","text":"","title":"Methods"},{"location":"api/tifeatures/dbmodel/#copy","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"api/tifeatures/dbmodel/#dict","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"api/tifeatures/dbmodel/#json","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"api/tifeatures/dbmodel/#datetimecolumn","text":"class DatetimeColumn ( __pydantic_self__ , ** data : Any )","title":"DatetimeColumn"},{"location":"api/tifeatures/dbmodel/#ancestors-in-mro_1","text":"tifeatures.dbmodel.Column pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/dbmodel/#class-variables_1","text":"Config","title":"Class variables"},{"location":"api/tifeatures/dbmodel/#static-methods_1","text":"","title":"Static methods"},{"location":"api/tifeatures/dbmodel/#construct_1","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"api/tifeatures/dbmodel/#from_orm_1","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"api/tifeatures/dbmodel/#parse_file_1","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"api/tifeatures/dbmodel/#parse_obj_1","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"api/tifeatures/dbmodel/#parse_raw_1","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"api/tifeatures/dbmodel/#schema_1","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"api/tifeatures/dbmodel/#schema_json_1","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"api/tifeatures/dbmodel/#update_forward_refs_1","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"api/tifeatures/dbmodel/#validate_1","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"api/tifeatures/dbmodel/#instance-variables_1","text":"json_type Return JSON field type.","title":"Instance variables"},{"location":"api/tifeatures/dbmodel/#methods_1","text":"","title":"Methods"},{"location":"api/tifeatures/dbmodel/#copy_1","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"api/tifeatures/dbmodel/#dict_1","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"api/tifeatures/dbmodel/#json_1","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"api/tifeatures/dbmodel/#geometrycolumn","text":"class GeometryColumn ( __pydantic_self__ , ** data : Any )","title":"GeometryColumn"},{"location":"api/tifeatures/dbmodel/#ancestors-in-mro_2","text":"tifeatures.dbmodel.Column pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/dbmodel/#class-variables_2","text":"Config","title":"Class variables"},{"location":"api/tifeatures/dbmodel/#static-methods_2","text":"","title":"Static methods"},{"location":"api/tifeatures/dbmodel/#construct_2","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"api/tifeatures/dbmodel/#from_orm_2","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"api/tifeatures/dbmodel/#parse_file_2","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"api/tifeatures/dbmodel/#parse_obj_2","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"api/tifeatures/dbmodel/#parse_raw_2","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"api/tifeatures/dbmodel/#schema_2","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"api/tifeatures/dbmodel/#schema_json_2","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"api/tifeatures/dbmodel/#update_forward_refs_2","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"api/tifeatures/dbmodel/#validate_2","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"api/tifeatures/dbmodel/#instance-variables_2","text":"json_type Return JSON field type.","title":"Instance variables"},{"location":"api/tifeatures/dbmodel/#methods_2","text":"","title":"Methods"},{"location":"api/tifeatures/dbmodel/#copy_2","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"api/tifeatures/dbmodel/#dict_2","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"api/tifeatures/dbmodel/#json_2","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"api/tifeatures/dbmodel/#table","text":"class Table ( __pydantic_self__ , ** data : Any )","title":"Table"},{"location":"api/tifeatures/dbmodel/#ancestors-in-mro_3","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/dbmodel/#descendants_1","text":"tifeatures.layer.Table","title":"Descendants"},{"location":"api/tifeatures/dbmodel/#class-variables_3","text":"Config","title":"Class variables"},{"location":"api/tifeatures/dbmodel/#static-methods_3","text":"","title":"Static methods"},{"location":"api/tifeatures/dbmodel/#construct_3","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"api/tifeatures/dbmodel/#from_orm_3","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"api/tifeatures/dbmodel/#parse_file_3","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"api/tifeatures/dbmodel/#parse_obj_3","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"api/tifeatures/dbmodel/#parse_raw_3","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"api/tifeatures/dbmodel/#schema_3","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"api/tifeatures/dbmodel/#schema_json_3","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"api/tifeatures/dbmodel/#update_forward_refs_3","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"api/tifeatures/dbmodel/#validate_3","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"api/tifeatures/dbmodel/#instance-variables_3","text":"id_column_info Return Column for a unique identifier.","title":"Instance variables"},{"location":"api/tifeatures/dbmodel/#methods_3","text":"","title":"Methods"},{"location":"api/tifeatures/dbmodel/#columns","text":"def columns ( self , properties : Union [ List [ str ], NoneType ] = None ) -> List [ str ] Return table columns optionally filtered to only include columns from properties.","title":"columns"},{"location":"api/tifeatures/dbmodel/#copy_3","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"api/tifeatures/dbmodel/#dict_3","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"api/tifeatures/dbmodel/#get_column","text":"def get_column ( self , property_name : str ) -> Union [ tifeatures . dbmodel . Column , NoneType ] Return column info.","title":"get_column"},{"location":"api/tifeatures/dbmodel/#get_datetime_column","text":"def get_datetime_column ( self , name : Union [ str , NoneType ] = None ) -> Union [ tifeatures . dbmodel . Column , NoneType ] Return the Column for either the passed in tstz column or the first tstz column.","title":"get_datetime_column"},{"location":"api/tifeatures/dbmodel/#get_geometry_column","text":"def get_geometry_column ( self , name : Union [ str , NoneType ] = None ) -> Union [ tifeatures . dbmodel . GeometryColumn , NoneType ] Return the name of the first geometry column.","title":"get_geometry_column"},{"location":"api/tifeatures/dbmodel/#json_3","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"api/tifeatures/dependencies/","text":"Module tifeatures.dependencies \u00b6 tifeatures dependencies. None Functions \u00b6 CollectionParams \u00b6 def CollectionParams ( request : starlette . requests . Request , collectionId : str = Path ( Ellipsis ) ) -> tifeatures . layer . Table Return Layer Object. ItemOutputType \u00b6 def ItemOutputType ( request : starlette . requests . Request , f : Union [ tifeatures . resources . enums . ItemResponseType , NoneType ] = Query ( None ) ) -> Union [ tifeatures . resources . enums . MediaType , NoneType ] Output MediaType: json or html. ItemsOutputType \u00b6 def ItemsOutputType ( request : starlette . requests . Request , f : Union [ tifeatures . resources . enums . ItemsResponseType , NoneType ] = Query ( None ) ) -> Union [ tifeatures . resources . enums . MediaType , NoneType ] Output MediaType: json or html. OutputType \u00b6 def OutputType ( request : starlette . requests . Request , f : Union [ tifeatures . resources . enums . ResponseType , NoneType ] = Query ( None ) ) -> Union [ tifeatures . resources . enums . MediaType , NoneType ] Output MediaType: json or html. QueryablesOutputType \u00b6 def QueryablesOutputType ( request : starlette . requests . Request , f : Union [ tifeatures . resources . enums . QueryablesResponseType , NoneType ] = Query ( None ) ) -> Union [ tifeatures . resources . enums . MediaType , NoneType ] Output MediaType: json or html. accept_media_type \u00b6 def accept_media_type ( accept : str , mediatypes : List [ tifeatures . resources . enums . MediaType ] ) -> Union [ tifeatures . resources . enums . MediaType , NoneType ] Return MediaType based on accept header and available mediatype. Links: - www.w3.org/Protocols/rfc2616/rfc2616-sec14.html - developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept bbox_query \u00b6 def bbox_query ( bbox : Union [ str , NoneType ] = Query ( None ) ) -> Union [ List [ float ], NoneType ] BBox dependency. datetime_query \u00b6 def datetime_query ( datetime : Union [ str , NoneType ] = Query ( None ) ) -> Union [ List [ str ], NoneType ] Datetime dependency. filter_query \u00b6 def filter_query ( query : Union [ str , NoneType ] = Query ( None ), filter_lang : Union [ tifeatures . resources . enums . FilterLang , NoneType ] = Query ( None ) ) -> Union [ ForwardRef ( 'Node' ), pygeofilter . values . Geometry , pygeofilter . values . Envelope , datetime . date , datetime . datetime , datetime . timedelta , pygeofilter . values . Interval , bool , float , int , str , list , NoneType ] Parse Filter Query. ids_query \u00b6 def ids_query ( ids : Union [ str , NoneType ] = Query ( None ) ) -> Union [ List [ str ], NoneType ] Ids dependency. properties_query \u00b6 def properties_query ( properties : Union [ str , NoneType ] = Query ( None ) ) -> Union [ List [ str ], NoneType ] Return property list. sortby_query \u00b6 def sortby_query ( sortby : Union [ str , NoneType ] = Query ( None ) ) Sortby dependency.","title":"dependencies"},{"location":"api/tifeatures/dependencies/#module-tifeaturesdependencies","text":"tifeatures dependencies. None","title":"Module tifeatures.dependencies"},{"location":"api/tifeatures/dependencies/#functions","text":"","title":"Functions"},{"location":"api/tifeatures/dependencies/#collectionparams","text":"def CollectionParams ( request : starlette . requests . Request , collectionId : str = Path ( Ellipsis ) ) -> tifeatures . layer . Table Return Layer Object.","title":"CollectionParams"},{"location":"api/tifeatures/dependencies/#itemoutputtype","text":"def ItemOutputType ( request : starlette . requests . Request , f : Union [ tifeatures . resources . enums . ItemResponseType , NoneType ] = Query ( None ) ) -> Union [ tifeatures . resources . enums . MediaType , NoneType ] Output MediaType: json or html.","title":"ItemOutputType"},{"location":"api/tifeatures/dependencies/#itemsoutputtype","text":"def ItemsOutputType ( request : starlette . requests . Request , f : Union [ tifeatures . resources . enums . ItemsResponseType , NoneType ] = Query ( None ) ) -> Union [ tifeatures . resources . enums . MediaType , NoneType ] Output MediaType: json or html.","title":"ItemsOutputType"},{"location":"api/tifeatures/dependencies/#outputtype","text":"def OutputType ( request : starlette . requests . Request , f : Union [ tifeatures . resources . enums . ResponseType , NoneType ] = Query ( None ) ) -> Union [ tifeatures . resources . enums . MediaType , NoneType ] Output MediaType: json or html.","title":"OutputType"},{"location":"api/tifeatures/dependencies/#queryablesoutputtype","text":"def QueryablesOutputType ( request : starlette . requests . Request , f : Union [ tifeatures . resources . enums . QueryablesResponseType , NoneType ] = Query ( None ) ) -> Union [ tifeatures . resources . enums . MediaType , NoneType ] Output MediaType: json or html.","title":"QueryablesOutputType"},{"location":"api/tifeatures/dependencies/#accept_media_type","text":"def accept_media_type ( accept : str , mediatypes : List [ tifeatures . resources . enums . MediaType ] ) -> Union [ tifeatures . resources . enums . MediaType , NoneType ] Return MediaType based on accept header and available mediatype. Links: - www.w3.org/Protocols/rfc2616/rfc2616-sec14.html - developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept","title":"accept_media_type"},{"location":"api/tifeatures/dependencies/#bbox_query","text":"def bbox_query ( bbox : Union [ str , NoneType ] = Query ( None ) ) -> Union [ List [ float ], NoneType ] BBox dependency.","title":"bbox_query"},{"location":"api/tifeatures/dependencies/#datetime_query","text":"def datetime_query ( datetime : Union [ str , NoneType ] = Query ( None ) ) -> Union [ List [ str ], NoneType ] Datetime dependency.","title":"datetime_query"},{"location":"api/tifeatures/dependencies/#filter_query","text":"def filter_query ( query : Union [ str , NoneType ] = Query ( None ), filter_lang : Union [ tifeatures . resources . enums . FilterLang , NoneType ] = Query ( None ) ) -> Union [ ForwardRef ( 'Node' ), pygeofilter . values . Geometry , pygeofilter . values . Envelope , datetime . date , datetime . datetime , datetime . timedelta , pygeofilter . values . Interval , bool , float , int , str , list , NoneType ] Parse Filter Query.","title":"filter_query"},{"location":"api/tifeatures/dependencies/#ids_query","text":"def ids_query ( ids : Union [ str , NoneType ] = Query ( None ) ) -> Union [ List [ str ], NoneType ] Ids dependency.","title":"ids_query"},{"location":"api/tifeatures/dependencies/#properties_query","text":"def properties_query ( properties : Union [ str , NoneType ] = Query ( None ) ) -> Union [ List [ str ], NoneType ] Return property list.","title":"properties_query"},{"location":"api/tifeatures/dependencies/#sortby_query","text":"def sortby_query ( sortby : Union [ str , NoneType ] = Query ( None ) ) Sortby dependency.","title":"sortby_query"},{"location":"api/tifeatures/errors/","text":"Module tifeatures.errors \u00b6 tifeatures.errors: Error classes. None Variables \u00b6 DEFAULT_STATUS_CODES logger Functions \u00b6 add_exception_handlers \u00b6 def add_exception_handlers ( app : fastapi . applications . FastAPI , status_codes : Dict [ Type [ Exception ], int ] ) -> None Add exception handlers to the FastAPI app. exception_handler_factory \u00b6 def exception_handler_factory ( status_code : int ) -> Callable Create a FastAPI exception handler from a status code. Classes \u00b6 InvalidBBox \u00b6 class InvalidBBox ( / , * args , ** kwargs ) Ancestors (in MRO) \u00b6 tifeatures.errors.TiFeaturesError builtins.Exception builtins.BaseException Class variables \u00b6 args Methods \u00b6 with_traceback \u00b6 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. InvalidDatetime \u00b6 class InvalidDatetime ( / , * args , ** kwargs ) Ancestors (in MRO) \u00b6 tifeatures.errors.TiFeaturesError builtins.Exception builtins.BaseException Class variables \u00b6 args Methods \u00b6 with_traceback \u00b6 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. InvalidDatetimeColumnName \u00b6 class InvalidDatetimeColumnName ( / , * args , ** kwargs ) Ancestors (in MRO) \u00b6 tifeatures.errors.TiFeaturesError builtins.Exception builtins.BaseException Class variables \u00b6 args Methods \u00b6 with_traceback \u00b6 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. InvalidGeometryColumnName \u00b6 class InvalidGeometryColumnName ( / , * args , ** kwargs ) Ancestors (in MRO) \u00b6 tifeatures.errors.TiFeaturesError builtins.Exception builtins.BaseException Class variables \u00b6 args Methods \u00b6 with_traceback \u00b6 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. InvalidPropertyName \u00b6 class InvalidPropertyName ( / , * args , ** kwargs ) Ancestors (in MRO) \u00b6 tifeatures.errors.TiFeaturesError builtins.Exception builtins.BaseException Class variables \u00b6 args Methods \u00b6 with_traceback \u00b6 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. MissingDatetimeColumn \u00b6 class MissingDatetimeColumn ( / , * args , ** kwargs ) Ancestors (in MRO) \u00b6 tifeatures.errors.TiFeaturesError builtins.Exception builtins.BaseException Class variables \u00b6 args Methods \u00b6 with_traceback \u00b6 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. MissingGeometryColumn \u00b6 class MissingGeometryColumn ( / , * args , ** kwargs ) Ancestors (in MRO) \u00b6 tifeatures.errors.TiFeaturesError builtins.Exception builtins.BaseException Class variables \u00b6 args Methods \u00b6 with_traceback \u00b6 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. NoPrimaryKey \u00b6 class NoPrimaryKey ( / , * args , ** kwargs ) Ancestors (in MRO) \u00b6 tifeatures.errors.TiFeaturesError builtins.Exception builtins.BaseException Class variables \u00b6 args Methods \u00b6 with_traceback \u00b6 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. NotFound \u00b6 class NotFound ( / , * args , ** kwargs ) Ancestors (in MRO) \u00b6 tifeatures.errors.TiFeaturesError builtins.Exception builtins.BaseException Class variables \u00b6 args Methods \u00b6 with_traceback \u00b6 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. TiFeaturesError \u00b6 class TiFeaturesError ( / , * args , ** kwargs ) Ancestors (in MRO) \u00b6 builtins.Exception builtins.BaseException Descendants \u00b6 tifeatures.errors.NotFound tifeatures.errors.NoPrimaryKey tifeatures.errors.MissingGeometryColumn tifeatures.errors.MissingDatetimeColumn tifeatures.errors.InvalidBBox tifeatures.errors.InvalidPropertyName tifeatures.errors.InvalidGeometryColumnName tifeatures.errors.InvalidDatetimeColumnName tifeatures.errors.InvalidDatetime Class variables \u00b6 args Methods \u00b6 with_traceback \u00b6 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"errors"},{"location":"api/tifeatures/errors/#module-tifeatureserrors","text":"tifeatures.errors: Error classes. None","title":"Module tifeatures.errors"},{"location":"api/tifeatures/errors/#variables","text":"DEFAULT_STATUS_CODES logger","title":"Variables"},{"location":"api/tifeatures/errors/#functions","text":"","title":"Functions"},{"location":"api/tifeatures/errors/#add_exception_handlers","text":"def add_exception_handlers ( app : fastapi . applications . FastAPI , status_codes : Dict [ Type [ Exception ], int ] ) -> None Add exception handlers to the FastAPI app.","title":"add_exception_handlers"},{"location":"api/tifeatures/errors/#exception_handler_factory","text":"def exception_handler_factory ( status_code : int ) -> Callable Create a FastAPI exception handler from a status code.","title":"exception_handler_factory"},{"location":"api/tifeatures/errors/#classes","text":"","title":"Classes"},{"location":"api/tifeatures/errors/#invalidbbox","text":"class InvalidBBox ( / , * args , ** kwargs )","title":"InvalidBBox"},{"location":"api/tifeatures/errors/#ancestors-in-mro","text":"tifeatures.errors.TiFeaturesError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/errors/#class-variables","text":"args","title":"Class variables"},{"location":"api/tifeatures/errors/#methods","text":"","title":"Methods"},{"location":"api/tifeatures/errors/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"api/tifeatures/errors/#invaliddatetime","text":"class InvalidDatetime ( / , * args , ** kwargs )","title":"InvalidDatetime"},{"location":"api/tifeatures/errors/#ancestors-in-mro_1","text":"tifeatures.errors.TiFeaturesError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/errors/#class-variables_1","text":"args","title":"Class variables"},{"location":"api/tifeatures/errors/#methods_1","text":"","title":"Methods"},{"location":"api/tifeatures/errors/#with_traceback_1","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"api/tifeatures/errors/#invaliddatetimecolumnname","text":"class InvalidDatetimeColumnName ( / , * args , ** kwargs )","title":"InvalidDatetimeColumnName"},{"location":"api/tifeatures/errors/#ancestors-in-mro_2","text":"tifeatures.errors.TiFeaturesError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/errors/#class-variables_2","text":"args","title":"Class variables"},{"location":"api/tifeatures/errors/#methods_2","text":"","title":"Methods"},{"location":"api/tifeatures/errors/#with_traceback_2","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"api/tifeatures/errors/#invalidgeometrycolumnname","text":"class InvalidGeometryColumnName ( / , * args , ** kwargs )","title":"InvalidGeometryColumnName"},{"location":"api/tifeatures/errors/#ancestors-in-mro_3","text":"tifeatures.errors.TiFeaturesError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/errors/#class-variables_3","text":"args","title":"Class variables"},{"location":"api/tifeatures/errors/#methods_3","text":"","title":"Methods"},{"location":"api/tifeatures/errors/#with_traceback_3","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"api/tifeatures/errors/#invalidpropertyname","text":"class InvalidPropertyName ( / , * args , ** kwargs )","title":"InvalidPropertyName"},{"location":"api/tifeatures/errors/#ancestors-in-mro_4","text":"tifeatures.errors.TiFeaturesError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/errors/#class-variables_4","text":"args","title":"Class variables"},{"location":"api/tifeatures/errors/#methods_4","text":"","title":"Methods"},{"location":"api/tifeatures/errors/#with_traceback_4","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"api/tifeatures/errors/#missingdatetimecolumn","text":"class MissingDatetimeColumn ( / , * args , ** kwargs )","title":"MissingDatetimeColumn"},{"location":"api/tifeatures/errors/#ancestors-in-mro_5","text":"tifeatures.errors.TiFeaturesError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/errors/#class-variables_5","text":"args","title":"Class variables"},{"location":"api/tifeatures/errors/#methods_5","text":"","title":"Methods"},{"location":"api/tifeatures/errors/#with_traceback_5","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"api/tifeatures/errors/#missinggeometrycolumn","text":"class MissingGeometryColumn ( / , * args , ** kwargs )","title":"MissingGeometryColumn"},{"location":"api/tifeatures/errors/#ancestors-in-mro_6","text":"tifeatures.errors.TiFeaturesError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/errors/#class-variables_6","text":"args","title":"Class variables"},{"location":"api/tifeatures/errors/#methods_6","text":"","title":"Methods"},{"location":"api/tifeatures/errors/#with_traceback_6","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"api/tifeatures/errors/#noprimarykey","text":"class NoPrimaryKey ( / , * args , ** kwargs )","title":"NoPrimaryKey"},{"location":"api/tifeatures/errors/#ancestors-in-mro_7","text":"tifeatures.errors.TiFeaturesError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/errors/#class-variables_7","text":"args","title":"Class variables"},{"location":"api/tifeatures/errors/#methods_7","text":"","title":"Methods"},{"location":"api/tifeatures/errors/#with_traceback_7","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"api/tifeatures/errors/#notfound","text":"class NotFound ( / , * args , ** kwargs )","title":"NotFound"},{"location":"api/tifeatures/errors/#ancestors-in-mro_8","text":"tifeatures.errors.TiFeaturesError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/errors/#class-variables_8","text":"args","title":"Class variables"},{"location":"api/tifeatures/errors/#methods_8","text":"","title":"Methods"},{"location":"api/tifeatures/errors/#with_traceback_8","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"api/tifeatures/errors/#tifeatureserror","text":"class TiFeaturesError ( / , * args , ** kwargs )","title":"TiFeaturesError"},{"location":"api/tifeatures/errors/#ancestors-in-mro_9","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/errors/#descendants","text":"tifeatures.errors.NotFound tifeatures.errors.NoPrimaryKey tifeatures.errors.MissingGeometryColumn tifeatures.errors.MissingDatetimeColumn tifeatures.errors.InvalidBBox tifeatures.errors.InvalidPropertyName tifeatures.errors.InvalidGeometryColumnName tifeatures.errors.InvalidDatetimeColumnName tifeatures.errors.InvalidDatetime","title":"Descendants"},{"location":"api/tifeatures/errors/#class-variables_9","text":"args","title":"Class variables"},{"location":"api/tifeatures/errors/#methods_9","text":"","title":"Methods"},{"location":"api/tifeatures/errors/#with_traceback_9","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"api/tifeatures/factory/","text":"Module tifeatures.factory \u00b6 tifeatures.factory: router factories. None Variables \u00b6 DEFAULT_TEMPLATES Functions \u00b6 create_csv_rows \u00b6 def create_csv_rows ( data : Iterable [ Dict ] ) -> Generator [ str , NoneType , NoneType ] Creates an iterator that returns lines of csv from an iterable of dicts. Classes \u00b6 Endpoints \u00b6 class Endpoints ( router : fastapi . routing . APIRouter = < factory > , collection_dependency : Callable [ ... , tifeatures . layer . CollectionLayer ] = < function CollectionParams at 0x7fce2f9be8b0 > , router_prefix : str = '' , title : str = 'TiFeatures' , templates : starlette . templating . Jinja2Templates = < starlette . templating . Jinja2Templates object at 0x7fce2eea0c70 > ) Class variables \u00b6 router_prefix templates title Methods \u00b6 collection_dependency \u00b6 def collection_dependency ( request : starlette . requests . Request , collectionId : str = Path ( Ellipsis ) ) -> tifeatures . layer . Table Return Layer Object. register_collections \u00b6 def register_collections ( self ) Register Collections endpoints. register_conformance \u00b6 def register_conformance ( self ) -> None Register conformance endpoint. register_landing \u00b6 def register_landing ( self ) -> None Register landing endpoint. url_for \u00b6 def url_for ( self , request : starlette . requests . Request , name : str , ** path_params : Any ) -> str Return full url (with prefix) for a specific handler.","title":"factory"},{"location":"api/tifeatures/factory/#module-tifeaturesfactory","text":"tifeatures.factory: router factories. None","title":"Module tifeatures.factory"},{"location":"api/tifeatures/factory/#variables","text":"DEFAULT_TEMPLATES","title":"Variables"},{"location":"api/tifeatures/factory/#functions","text":"","title":"Functions"},{"location":"api/tifeatures/factory/#create_csv_rows","text":"def create_csv_rows ( data : Iterable [ Dict ] ) -> Generator [ str , NoneType , NoneType ] Creates an iterator that returns lines of csv from an iterable of dicts.","title":"create_csv_rows"},{"location":"api/tifeatures/factory/#classes","text":"","title":"Classes"},{"location":"api/tifeatures/factory/#endpoints","text":"class Endpoints ( router : fastapi . routing . APIRouter = < factory > , collection_dependency : Callable [ ... , tifeatures . layer . CollectionLayer ] = < function CollectionParams at 0x7fce2f9be8b0 > , router_prefix : str = '' , title : str = 'TiFeatures' , templates : starlette . templating . Jinja2Templates = < starlette . templating . Jinja2Templates object at 0x7fce2eea0c70 > )","title":"Endpoints"},{"location":"api/tifeatures/factory/#class-variables","text":"router_prefix templates title","title":"Class variables"},{"location":"api/tifeatures/factory/#methods","text":"","title":"Methods"},{"location":"api/tifeatures/factory/#collection_dependency","text":"def collection_dependency ( request : starlette . requests . Request , collectionId : str = Path ( Ellipsis ) ) -> tifeatures . layer . Table Return Layer Object.","title":"collection_dependency"},{"location":"api/tifeatures/factory/#register_collections","text":"def register_collections ( self ) Register Collections endpoints.","title":"register_collections"},{"location":"api/tifeatures/factory/#register_conformance","text":"def register_conformance ( self ) -> None Register conformance endpoint.","title":"register_conformance"},{"location":"api/tifeatures/factory/#register_landing","text":"def register_landing ( self ) -> None Register landing endpoint.","title":"register_landing"},{"location":"api/tifeatures/factory/#url_for","text":"def url_for ( self , request : starlette . requests . Request , name : str , ** path_params : Any ) -> str Return full url (with prefix) for a specific handler.","title":"url_for"},{"location":"api/tifeatures/layer/","text":"Module tifeatures.layer \u00b6 tifeatures.layers. None Variables \u00b6 geojson_schema Classes \u00b6 CollectionLayer \u00b6 class CollectionLayer ( __pydantic_self__ , ** data : Any ) Attributes \u00b6 Name Type Description Default id str Layer's name. None bounds list Layer's bounds (left, bottom, right, top). None crs str Coordinate reference system of the Collection. None title str Layer's title None description str Layer's description None Ancestors (in MRO) \u00b6 pydantic.main.BaseModel pydantic.utils.Representation Descendants \u00b6 tifeatures.layer.Table Class variables \u00b6 Config Static methods \u00b6 construct \u00b6 def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm \u00b6 def from_orm ( obj : Any ) -> 'Model' parse_file \u00b6 def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj \u00b6 def parse_obj ( obj : Any ) -> 'Model' parse_raw \u00b6 def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema \u00b6 def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json \u00b6 def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs \u00b6 def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate \u00b6 def validate ( value : Any ) -> 'Model' Instance variables \u00b6 queryables Return the queryables. Methods \u00b6 copy \u00b6 def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict \u00b6 def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. features \u00b6 def features ( self , pool : buildpg . asyncpg . BuildPgPool , * , ids_filter : Union [ List [ str ], NoneType ] = None , bbox_filter : Union [ List [ float ], NoneType ] = None , datetime_filter : Union [ List [ str ], NoneType ] = None , properties_filter : Union [ List [ Tuple [ str , str ]], NoneType ] = None , cql_filter : Union [ ForwardRef ( 'Node' ), pygeofilter . values . Geometry , pygeofilter . values . Envelope , datetime . date , datetime . datetime , datetime . timedelta , pygeofilter . values . Interval , bool , float , int , str , list , NoneType ] = None , sortby : Union [ str , NoneType ] = None , properties : Union [ List [ str ], NoneType ] = None , geom : Union [ str , NoneType ] = None , dt : Union [ str , NoneType ] = None , limit : Union [ int , NoneType ] = None , offset : Union [ int , NoneType ] = None , bbox_only : Union [ bool , NoneType ] = None , simplify : Union [ float , NoneType ] = None , geom_as_wkt : bool = False ) -> Tuple [ tifeatures . layer . FeatureCollection , int ] Return a FeatureCollection and the number of matched items. json \u00b6 def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Feature \u00b6 class Feature ( / , * args , ** kwargs ) Ancestors (in MRO) \u00b6 builtins.dict Methods \u00b6 clear \u00b6 def clear ( ... ) D.clear() -> None. Remove all items from D. copy \u00b6 def copy ( ... ) D.copy() -> a shallow copy of D fromkeys \u00b6 def fromkeys ( iterable , value = None , / ) Create a new dictionary with keys from iterable and values set to value. get \u00b6 def get ( self , key , default = None , / ) Return the value for key if key is in the dictionary, else default. items \u00b6 def items ( ... ) D.items() -> a set-like object providing a view on D's items keys \u00b6 def keys ( ... ) D.keys() -> a set-like object providing a view on D's keys pop \u00b6 def pop ( ... ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised popitem \u00b6 def popitem ( self , / ) Remove and return a (key, value) pair as a 2-tuple. Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the dict is empty. setdefault \u00b6 def setdefault ( self , key , default = None , / ) Insert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default. update \u00b6 def update ( ... ) D.update([E, ]**F) -> None. Update D from dict/iterable E and F. If E is present and has a .keys() method, then does: for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v In either case, this is followed by: for k in F: D[k] = F[k] values \u00b6 def values ( ... ) D.values() -> an object providing a view on D's values FeatureCollection \u00b6 class FeatureCollection ( / , * args , ** kwargs ) Ancestors (in MRO) \u00b6 builtins.dict Methods \u00b6 clear \u00b6 def clear ( ... ) D.clear() -> None. Remove all items from D. copy \u00b6 def copy ( ... ) D.copy() -> a shallow copy of D fromkeys \u00b6 def fromkeys ( iterable , value = None , / ) Create a new dictionary with keys from iterable and values set to value. get \u00b6 def get ( self , key , default = None , / ) Return the value for key if key is in the dictionary, else default. items \u00b6 def items ( ... ) D.items() -> a set-like object providing a view on D's items keys \u00b6 def keys ( ... ) D.keys() -> a set-like object providing a view on D's keys pop \u00b6 def pop ( ... ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised popitem \u00b6 def popitem ( self , / ) Remove and return a (key, value) pair as a 2-tuple. Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the dict is empty. setdefault \u00b6 def setdefault ( self , key , default = None , / ) Insert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default. update \u00b6 def update ( ... ) D.update([E, ]**F) -> None. Update D from dict/iterable E and F. If E is present and has a .keys() method, then does: for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v In either case, this is followed by: for k in F: D[k] = F[k] values \u00b6 def values ( ... ) D.values() -> an object providing a view on D's values RawComponent \u00b6 class RawComponent ( val ) Ancestors (in MRO) \u00b6 buildpg.components.VarLiteral buildpg.components.RawDangerous builtins.str Static methods \u00b6 maketrans \u00b6 def maketrans ( ... ) Return a translation table usable for str.translate(). If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters to Unicode ordinals, strings or None. Character keys will be then converted to ordinals. If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in x will be mapped to the character at the same position in y. If there is a third argument, it must be a string, whose characters will be mapped to None in the result. Instance variables \u00b6 val Methods \u00b6 capitalize \u00b6 def capitalize ( self , / ) Return a capitalized version of the string. More specifically, make the first character have upper case and the rest lower case. casefold \u00b6 def casefold ( self , / ) Return a version of the string suitable for caseless comparisons. center \u00b6 def center ( self , width , fillchar = ' ' , / ) Return a centered string of length width. Padding is done using the specified fill character (default is a space). count \u00b6 def count ( ... ) S.count(sub[, start[, end]]) -> int Return the number of non-overlapping occurrences of substring sub in string S[start:end]. Optional arguments start and end are interpreted as in slice notation. encode \u00b6 def encode ( self , / , encoding = 'utf-8' , errors = 'strict' ) Encode the string using the codec registered for encoding. encoding The encoding in which to encode the string. errors The error handling scheme to use for encoding errors. The default is 'strict' meaning that encoding errors raise a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and 'xmlcharrefreplace' as well as any other name registered with codecs.register_error that can handle UnicodeEncodeErrors. endswith \u00b6 def endswith ( ... ) S.endswith(suffix[, start[, end]]) -> bool Return True if S ends with the specified suffix, False otherwise. With optional start, test S beginning at that position. With optional end, stop comparing S at that position. suffix can also be a tuple of strings to try. expandtabs \u00b6 def expandtabs ( self , / , tabsize = 8 ) Return a copy where all tab characters are expanded using spaces. If tabsize is not given, a tab size of 8 characters is assumed. find \u00b6 def find ( ... ) S.find(sub[, start[, end]]) -> int Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure. format \u00b6 def format ( ... ) S.format( args, * kwargs) -> str Return a formatted version of S, using substitutions from args and kwargs. The substitutions are identified by braces ('{' and '}'). format_map \u00b6 def format_map ( ... ) S.format_map(mapping) -> str Return a formatted version of S, using substitutions from mapping. The substitutions are identified by braces ('{' and '}'). index \u00b6 def index ( ... ) S.index(sub[, start[, end]]) -> int Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Raises ValueError when the substring is not found. isalnum \u00b6 def isalnum ( self , / ) Return True if the string is an alpha-numeric string, False otherwise. A string is alpha-numeric if all characters in the string are alpha-numeric and there is at least one character in the string. isalpha \u00b6 def isalpha ( self , / ) Return True if the string is an alphabetic string, False otherwise. A string is alphabetic if all characters in the string are alphabetic and there is at least one character in the string. isascii \u00b6 def isascii ( self , / ) Return True if all characters in the string are ASCII, False otherwise. ASCII characters have code points in the range U+0000-U+007F. Empty string is ASCII too. isdecimal \u00b6 def isdecimal ( self , / ) Return True if the string is a decimal string, False otherwise. A string is a decimal string if all characters in the string are decimal and there is at least one character in the string. isdigit \u00b6 def isdigit ( self , / ) Return True if the string is a digit string, False otherwise. A string is a digit string if all characters in the string are digits and there is at least one character in the string. isidentifier \u00b6 def isidentifier ( self , / ) Return True if the string is a valid Python identifier, False otherwise. Call keyword.iskeyword(s) to test whether string s is a reserved identifier, such as \"def\" or \"class\". islower \u00b6 def islower ( self , / ) Return True if the string is a lowercase string, False otherwise. A string is lowercase if all cased characters in the string are lowercase and there is at least one cased character in the string. isnumeric \u00b6 def isnumeric ( self , / ) Return True if the string is a numeric string, False otherwise. A string is numeric if all characters in the string are numeric and there is at least one character in the string. isprintable \u00b6 def isprintable ( self , / ) Return True if the string is printable, False otherwise. A string is printable if all of its characters are considered printable in repr() or if it is empty. isspace \u00b6 def isspace ( self , / ) Return True if the string is a whitespace string, False otherwise. A string is whitespace if all characters in the string are whitespace and there is at least one character in the string. istitle \u00b6 def istitle ( self , / ) Return True if the string is a title-cased string, False otherwise. In a title-cased string, upper- and title-case characters may only follow uncased characters and lowercase characters only cased ones. isupper \u00b6 def isupper ( self , / ) Return True if the string is an uppercase string, False otherwise. A string is uppercase if all cased characters in the string are uppercase and there is at least one cased character in the string. join \u00b6 def join ( self , iterable , / ) Concatenate any number of strings. The string whose method is called is inserted in between each given string. The result is returned as a new string. Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs' ljust \u00b6 def ljust ( self , width , fillchar = ' ' , / ) Return a left-justified string of length width. Padding is done using the specified fill character (default is a space). lower \u00b6 def lower ( self , / ) Return a copy of the string converted to lowercase. lstrip \u00b6 def lstrip ( self , chars = None , / ) Return a copy of the string with leading whitespace removed. If chars is given and not None, remove characters in chars instead. partition \u00b6 def partition ( self , sep , / ) Partition the string into three parts using the given separator. This will search for the separator in the string. If the separator is found, returns a 3-tuple containing the part before the separator, the separator itself, and the part after it. If the separator is not found, returns a 3-tuple containing the original string and two empty strings. render \u00b6 def render ( self ) Render replace \u00b6 def replace ( self , old , new , count =- 1 , / ) Return a copy with all occurrences of substring old replaced by new. count Maximum number of occurrences to replace. -1 (the default value) means replace all occurrences. If the optional argument count is given, only the first count occurrences are replaced. rfind \u00b6 def rfind ( ... ) S.rfind(sub[, start[, end]]) -> int Return the highest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure. rindex \u00b6 def rindex ( ... ) S.rindex(sub[, start[, end]]) -> int Return the highest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Raises ValueError when the substring is not found. rjust \u00b6 def rjust ( self , width , fillchar = ' ' , / ) Return a right-justified string of length width. Padding is done using the specified fill character (default is a space). rpartition \u00b6 def rpartition ( self , sep , / ) Partition the string into three parts using the given separator. This will search for the separator in the string, starting at the end. If the separator is found, returns a 3-tuple containing the part before the separator, the separator itself, and the part after it. If the separator is not found, returns a 3-tuple containing two empty strings and the original string. rsplit \u00b6 def rsplit ( self , / , sep = None , maxsplit =- 1 ) Return a list of the words in the string, using sep as the delimiter string. sep The delimiter according which to split the string. None (the default value) means split according to any whitespace, and discard empty strings from the result. maxsplit Maximum number of splits to do. -1 (the default value) means no limit. Splits are done starting at the end of the string and working to the front. rstrip \u00b6 def rstrip ( self , chars = None , / ) Return a copy of the string with trailing whitespace removed. If chars is given and not None, remove characters in chars instead. split \u00b6 def split ( self , / , sep = None , maxsplit =- 1 ) Return a list of the words in the string, using sep as the delimiter string. sep The delimiter according which to split the string. None (the default value) means split according to any whitespace, and discard empty strings from the result. maxsplit Maximum number of splits to do. -1 (the default value) means no limit. splitlines \u00b6 def splitlines ( self , / , keepends = False ) Return a list of the lines in the string, breaking at line boundaries. Line breaks are not included in the resulting list unless keepends is given and true. startswith \u00b6 def startswith ( ... ) S.startswith(prefix[, start[, end]]) -> bool Return True if S starts with the specified prefix, False otherwise. With optional start, test S beginning at that position. With optional end, stop comparing S at that position. prefix can also be a tuple of strings to try. strip \u00b6 def strip ( self , chars = None , / ) Return a copy of the string with leading and trailing whitespace removed. If chars is given and not None, remove characters in chars instead. swapcase \u00b6 def swapcase ( self , / ) Convert uppercase characters to lowercase and lowercase characters to uppercase. title \u00b6 def title ( self , / ) Return a version of the string where each word is titlecased. More specifically, words start with uppercased characters and all remaining cased characters have lower case. translate \u00b6 def translate ( self , table , / ) Replace each character in the string using the given translation table. table Translation table, which must be a mapping of Unicode ordinals to Unicode ordinals, strings, or None. The table must implement lookup/indexing via getitem , for instance a dictionary or list. If this operation raises LookupError, the character is left untouched. Characters mapped to None are deleted. upper \u00b6 def upper ( self , / ) Return a copy of the string converted to uppercase. zfill \u00b6 def zfill ( self , width , / ) Pad a numeric string with zeros on the left, to fill a field of the given width. The string is never truncated. Table \u00b6 class Table ( __pydantic_self__ , ** data : Any ) Attributes \u00b6 Name Type Description Default id str Layer's name. None bounds list Layer's bounds (left, bottom, right, top). None crs str Coordinate reference system of the Table. None type str Layer's type. None schema str Table's database schema (e.g public). None geometry_type str Table's geometry type (e.g polygon). None srid int Table's SRID None geometry_column str Name of the geomtry column in the table. None properties Dict Properties available in the table. None Ancestors (in MRO) \u00b6 tifeatures.layer.CollectionLayer tifeatures.dbmodel.Table pydantic.main.BaseModel pydantic.utils.Representation Class variables \u00b6 Config Static methods \u00b6 bounds_default \u00b6 def bounds_default ( values ) Get default bounds from the first geometry columns. construct \u00b6 def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm \u00b6 def from_orm ( obj : Any ) -> 'Model' parse_file \u00b6 def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj \u00b6 def parse_obj ( obj : Any ) -> 'Model' parse_raw \u00b6 def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema \u00b6 def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json \u00b6 def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs \u00b6 def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate \u00b6 def validate ( value : Any ) -> 'Model' Instance variables \u00b6 id_column_info Return Column for a unique identifier. queryables Return the queryables. Methods \u00b6 columns \u00b6 def columns ( self , properties : Union [ List [ str ], NoneType ] = None ) -> List [ str ] Return table columns optionally filtered to only include columns from properties. copy \u00b6 def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict \u00b6 def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. features \u00b6 def features ( self , pool : buildpg . asyncpg . BuildPgPool , * , ids_filter : Union [ List [ str ], NoneType ] = None , bbox_filter : Union [ List [ float ], NoneType ] = None , datetime_filter : Union [ List [ str ], NoneType ] = None , properties_filter : Union [ List [ Tuple [ str , str ]], NoneType ] = None , cql_filter : Union [ ForwardRef ( 'Node' ), pygeofilter . values . Geometry , pygeofilter . values . Envelope , datetime . date , datetime . datetime , datetime . timedelta , pygeofilter . values . Interval , bool , float , int , str , list , NoneType ] = None , sortby : Union [ str , NoneType ] = None , properties : Union [ List [ str ], NoneType ] = None , geom : Union [ str , NoneType ] = None , dt : Union [ str , NoneType ] = None , limit : Union [ int , NoneType ] = None , offset : Union [ int , NoneType ] = None , bbox_only : Union [ bool , NoneType ] = None , simplify : Union [ float , NoneType ] = None , geom_as_wkt : bool = False ) -> Tuple [ tifeatures . layer . FeatureCollection , int ] Build and run Pg query. get_column \u00b6 def get_column ( self , property_name : str ) -> Union [ tifeatures . dbmodel . Column , NoneType ] Return column info. get_datetime_column \u00b6 def get_datetime_column ( self , name : Union [ str , NoneType ] = None ) -> Union [ tifeatures . dbmodel . Column , NoneType ] Return the Column for either the passed in tstz column or the first tstz column. get_geometry_column \u00b6 def get_geometry_column ( self , name : Union [ str , NoneType ] = None ) -> Union [ tifeatures . dbmodel . GeometryColumn , NoneType ] Return the name of the first geometry column. json \u00b6 def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"layer"},{"location":"api/tifeatures/layer/#module-tifeatureslayer","text":"tifeatures.layers. None","title":"Module tifeatures.layer"},{"location":"api/tifeatures/layer/#variables","text":"geojson_schema","title":"Variables"},{"location":"api/tifeatures/layer/#classes","text":"","title":"Classes"},{"location":"api/tifeatures/layer/#collectionlayer","text":"class CollectionLayer ( __pydantic_self__ , ** data : Any )","title":"CollectionLayer"},{"location":"api/tifeatures/layer/#attributes","text":"Name Type Description Default id str Layer's name. None bounds list Layer's bounds (left, bottom, right, top). None crs str Coordinate reference system of the Collection. None title str Layer's title None description str Layer's description None","title":"Attributes"},{"location":"api/tifeatures/layer/#ancestors-in-mro","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/layer/#descendants","text":"tifeatures.layer.Table","title":"Descendants"},{"location":"api/tifeatures/layer/#class-variables","text":"Config","title":"Class variables"},{"location":"api/tifeatures/layer/#static-methods","text":"","title":"Static methods"},{"location":"api/tifeatures/layer/#construct","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"api/tifeatures/layer/#from_orm","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"api/tifeatures/layer/#parse_file","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"api/tifeatures/layer/#parse_obj","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"api/tifeatures/layer/#parse_raw","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"api/tifeatures/layer/#schema","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"api/tifeatures/layer/#schema_json","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"api/tifeatures/layer/#update_forward_refs","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"api/tifeatures/layer/#validate","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"api/tifeatures/layer/#instance-variables","text":"queryables Return the queryables.","title":"Instance variables"},{"location":"api/tifeatures/layer/#methods","text":"","title":"Methods"},{"location":"api/tifeatures/layer/#copy","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"api/tifeatures/layer/#dict","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"api/tifeatures/layer/#features","text":"def features ( self , pool : buildpg . asyncpg . BuildPgPool , * , ids_filter : Union [ List [ str ], NoneType ] = None , bbox_filter : Union [ List [ float ], NoneType ] = None , datetime_filter : Union [ List [ str ], NoneType ] = None , properties_filter : Union [ List [ Tuple [ str , str ]], NoneType ] = None , cql_filter : Union [ ForwardRef ( 'Node' ), pygeofilter . values . Geometry , pygeofilter . values . Envelope , datetime . date , datetime . datetime , datetime . timedelta , pygeofilter . values . Interval , bool , float , int , str , list , NoneType ] = None , sortby : Union [ str , NoneType ] = None , properties : Union [ List [ str ], NoneType ] = None , geom : Union [ str , NoneType ] = None , dt : Union [ str , NoneType ] = None , limit : Union [ int , NoneType ] = None , offset : Union [ int , NoneType ] = None , bbox_only : Union [ bool , NoneType ] = None , simplify : Union [ float , NoneType ] = None , geom_as_wkt : bool = False ) -> Tuple [ tifeatures . layer . FeatureCollection , int ] Return a FeatureCollection and the number of matched items.","title":"features"},{"location":"api/tifeatures/layer/#json","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"api/tifeatures/layer/#feature","text":"class Feature ( / , * args , ** kwargs )","title":"Feature"},{"location":"api/tifeatures/layer/#ancestors-in-mro_1","text":"builtins.dict","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/layer/#methods_1","text":"","title":"Methods"},{"location":"api/tifeatures/layer/#clear","text":"def clear ( ... ) D.clear() -> None. Remove all items from D.","title":"clear"},{"location":"api/tifeatures/layer/#copy_1","text":"def copy ( ... ) D.copy() -> a shallow copy of D","title":"copy"},{"location":"api/tifeatures/layer/#fromkeys","text":"def fromkeys ( iterable , value = None , / ) Create a new dictionary with keys from iterable and values set to value.","title":"fromkeys"},{"location":"api/tifeatures/layer/#get","text":"def get ( self , key , default = None , / ) Return the value for key if key is in the dictionary, else default.","title":"get"},{"location":"api/tifeatures/layer/#items","text":"def items ( ... ) D.items() -> a set-like object providing a view on D's items","title":"items"},{"location":"api/tifeatures/layer/#keys","text":"def keys ( ... ) D.keys() -> a set-like object providing a view on D's keys","title":"keys"},{"location":"api/tifeatures/layer/#pop","text":"def pop ( ... ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised","title":"pop"},{"location":"api/tifeatures/layer/#popitem","text":"def popitem ( self , / ) Remove and return a (key, value) pair as a 2-tuple. Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the dict is empty.","title":"popitem"},{"location":"api/tifeatures/layer/#setdefault","text":"def setdefault ( self , key , default = None , / ) Insert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default.","title":"setdefault"},{"location":"api/tifeatures/layer/#update","text":"def update ( ... ) D.update([E, ]**F) -> None. Update D from dict/iterable E and F. If E is present and has a .keys() method, then does: for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v In either case, this is followed by: for k in F: D[k] = F[k]","title":"update"},{"location":"api/tifeatures/layer/#values","text":"def values ( ... ) D.values() -> an object providing a view on D's values","title":"values"},{"location":"api/tifeatures/layer/#featurecollection","text":"class FeatureCollection ( / , * args , ** kwargs )","title":"FeatureCollection"},{"location":"api/tifeatures/layer/#ancestors-in-mro_2","text":"builtins.dict","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/layer/#methods_2","text":"","title":"Methods"},{"location":"api/tifeatures/layer/#clear_1","text":"def clear ( ... ) D.clear() -> None. Remove all items from D.","title":"clear"},{"location":"api/tifeatures/layer/#copy_2","text":"def copy ( ... ) D.copy() -> a shallow copy of D","title":"copy"},{"location":"api/tifeatures/layer/#fromkeys_1","text":"def fromkeys ( iterable , value = None , / ) Create a new dictionary with keys from iterable and values set to value.","title":"fromkeys"},{"location":"api/tifeatures/layer/#get_1","text":"def get ( self , key , default = None , / ) Return the value for key if key is in the dictionary, else default.","title":"get"},{"location":"api/tifeatures/layer/#items_1","text":"def items ( ... ) D.items() -> a set-like object providing a view on D's items","title":"items"},{"location":"api/tifeatures/layer/#keys_1","text":"def keys ( ... ) D.keys() -> a set-like object providing a view on D's keys","title":"keys"},{"location":"api/tifeatures/layer/#pop_1","text":"def pop ( ... ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised","title":"pop"},{"location":"api/tifeatures/layer/#popitem_1","text":"def popitem ( self , / ) Remove and return a (key, value) pair as a 2-tuple. Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the dict is empty.","title":"popitem"},{"location":"api/tifeatures/layer/#setdefault_1","text":"def setdefault ( self , key , default = None , / ) Insert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default.","title":"setdefault"},{"location":"api/tifeatures/layer/#update_1","text":"def update ( ... ) D.update([E, ]**F) -> None. Update D from dict/iterable E and F. If E is present and has a .keys() method, then does: for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v In either case, this is followed by: for k in F: D[k] = F[k]","title":"update"},{"location":"api/tifeatures/layer/#values_1","text":"def values ( ... ) D.values() -> an object providing a view on D's values","title":"values"},{"location":"api/tifeatures/layer/#rawcomponent","text":"class RawComponent ( val )","title":"RawComponent"},{"location":"api/tifeatures/layer/#ancestors-in-mro_3","text":"buildpg.components.VarLiteral buildpg.components.RawDangerous builtins.str","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/layer/#static-methods_1","text":"","title":"Static methods"},{"location":"api/tifeatures/layer/#maketrans","text":"def maketrans ( ... ) Return a translation table usable for str.translate(). If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters to Unicode ordinals, strings or None. Character keys will be then converted to ordinals. If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in x will be mapped to the character at the same position in y. If there is a third argument, it must be a string, whose characters will be mapped to None in the result.","title":"maketrans"},{"location":"api/tifeatures/layer/#instance-variables_1","text":"val","title":"Instance variables"},{"location":"api/tifeatures/layer/#methods_3","text":"","title":"Methods"},{"location":"api/tifeatures/layer/#capitalize","text":"def capitalize ( self , / ) Return a capitalized version of the string. More specifically, make the first character have upper case and the rest lower case.","title":"capitalize"},{"location":"api/tifeatures/layer/#casefold","text":"def casefold ( self , / ) Return a version of the string suitable for caseless comparisons.","title":"casefold"},{"location":"api/tifeatures/layer/#center","text":"def center ( self , width , fillchar = ' ' , / ) Return a centered string of length width. Padding is done using the specified fill character (default is a space).","title":"center"},{"location":"api/tifeatures/layer/#count","text":"def count ( ... ) S.count(sub[, start[, end]]) -> int Return the number of non-overlapping occurrences of substring sub in string S[start:end]. Optional arguments start and end are interpreted as in slice notation.","title":"count"},{"location":"api/tifeatures/layer/#encode","text":"def encode ( self , / , encoding = 'utf-8' , errors = 'strict' ) Encode the string using the codec registered for encoding. encoding The encoding in which to encode the string. errors The error handling scheme to use for encoding errors. The default is 'strict' meaning that encoding errors raise a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and 'xmlcharrefreplace' as well as any other name registered with codecs.register_error that can handle UnicodeEncodeErrors.","title":"encode"},{"location":"api/tifeatures/layer/#endswith","text":"def endswith ( ... ) S.endswith(suffix[, start[, end]]) -> bool Return True if S ends with the specified suffix, False otherwise. With optional start, test S beginning at that position. With optional end, stop comparing S at that position. suffix can also be a tuple of strings to try.","title":"endswith"},{"location":"api/tifeatures/layer/#expandtabs","text":"def expandtabs ( self , / , tabsize = 8 ) Return a copy where all tab characters are expanded using spaces. If tabsize is not given, a tab size of 8 characters is assumed.","title":"expandtabs"},{"location":"api/tifeatures/layer/#find","text":"def find ( ... ) S.find(sub[, start[, end]]) -> int Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure.","title":"find"},{"location":"api/tifeatures/layer/#format","text":"def format ( ... ) S.format( args, * kwargs) -> str Return a formatted version of S, using substitutions from args and kwargs. The substitutions are identified by braces ('{' and '}').","title":"format"},{"location":"api/tifeatures/layer/#format_map","text":"def format_map ( ... ) S.format_map(mapping) -> str Return a formatted version of S, using substitutions from mapping. The substitutions are identified by braces ('{' and '}').","title":"format_map"},{"location":"api/tifeatures/layer/#index","text":"def index ( ... ) S.index(sub[, start[, end]]) -> int Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Raises ValueError when the substring is not found.","title":"index"},{"location":"api/tifeatures/layer/#isalnum","text":"def isalnum ( self , / ) Return True if the string is an alpha-numeric string, False otherwise. A string is alpha-numeric if all characters in the string are alpha-numeric and there is at least one character in the string.","title":"isalnum"},{"location":"api/tifeatures/layer/#isalpha","text":"def isalpha ( self , / ) Return True if the string is an alphabetic string, False otherwise. A string is alphabetic if all characters in the string are alphabetic and there is at least one character in the string.","title":"isalpha"},{"location":"api/tifeatures/layer/#isascii","text":"def isascii ( self , / ) Return True if all characters in the string are ASCII, False otherwise. ASCII characters have code points in the range U+0000-U+007F. Empty string is ASCII too.","title":"isascii"},{"location":"api/tifeatures/layer/#isdecimal","text":"def isdecimal ( self , / ) Return True if the string is a decimal string, False otherwise. A string is a decimal string if all characters in the string are decimal and there is at least one character in the string.","title":"isdecimal"},{"location":"api/tifeatures/layer/#isdigit","text":"def isdigit ( self , / ) Return True if the string is a digit string, False otherwise. A string is a digit string if all characters in the string are digits and there is at least one character in the string.","title":"isdigit"},{"location":"api/tifeatures/layer/#isidentifier","text":"def isidentifier ( self , / ) Return True if the string is a valid Python identifier, False otherwise. Call keyword.iskeyword(s) to test whether string s is a reserved identifier, such as \"def\" or \"class\".","title":"isidentifier"},{"location":"api/tifeatures/layer/#islower","text":"def islower ( self , / ) Return True if the string is a lowercase string, False otherwise. A string is lowercase if all cased characters in the string are lowercase and there is at least one cased character in the string.","title":"islower"},{"location":"api/tifeatures/layer/#isnumeric","text":"def isnumeric ( self , / ) Return True if the string is a numeric string, False otherwise. A string is numeric if all characters in the string are numeric and there is at least one character in the string.","title":"isnumeric"},{"location":"api/tifeatures/layer/#isprintable","text":"def isprintable ( self , / ) Return True if the string is printable, False otherwise. A string is printable if all of its characters are considered printable in repr() or if it is empty.","title":"isprintable"},{"location":"api/tifeatures/layer/#isspace","text":"def isspace ( self , / ) Return True if the string is a whitespace string, False otherwise. A string is whitespace if all characters in the string are whitespace and there is at least one character in the string.","title":"isspace"},{"location":"api/tifeatures/layer/#istitle","text":"def istitle ( self , / ) Return True if the string is a title-cased string, False otherwise. In a title-cased string, upper- and title-case characters may only follow uncased characters and lowercase characters only cased ones.","title":"istitle"},{"location":"api/tifeatures/layer/#isupper","text":"def isupper ( self , / ) Return True if the string is an uppercase string, False otherwise. A string is uppercase if all cased characters in the string are uppercase and there is at least one cased character in the string.","title":"isupper"},{"location":"api/tifeatures/layer/#join","text":"def join ( self , iterable , / ) Concatenate any number of strings. The string whose method is called is inserted in between each given string. The result is returned as a new string. Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'","title":"join"},{"location":"api/tifeatures/layer/#ljust","text":"def ljust ( self , width , fillchar = ' ' , / ) Return a left-justified string of length width. Padding is done using the specified fill character (default is a space).","title":"ljust"},{"location":"api/tifeatures/layer/#lower","text":"def lower ( self , / ) Return a copy of the string converted to lowercase.","title":"lower"},{"location":"api/tifeatures/layer/#lstrip","text":"def lstrip ( self , chars = None , / ) Return a copy of the string with leading whitespace removed. If chars is given and not None, remove characters in chars instead.","title":"lstrip"},{"location":"api/tifeatures/layer/#partition","text":"def partition ( self , sep , / ) Partition the string into three parts using the given separator. This will search for the separator in the string. If the separator is found, returns a 3-tuple containing the part before the separator, the separator itself, and the part after it. If the separator is not found, returns a 3-tuple containing the original string and two empty strings.","title":"partition"},{"location":"api/tifeatures/layer/#render","text":"def render ( self ) Render","title":"render"},{"location":"api/tifeatures/layer/#replace","text":"def replace ( self , old , new , count =- 1 , / ) Return a copy with all occurrences of substring old replaced by new. count Maximum number of occurrences to replace. -1 (the default value) means replace all occurrences. If the optional argument count is given, only the first count occurrences are replaced.","title":"replace"},{"location":"api/tifeatures/layer/#rfind","text":"def rfind ( ... ) S.rfind(sub[, start[, end]]) -> int Return the highest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure.","title":"rfind"},{"location":"api/tifeatures/layer/#rindex","text":"def rindex ( ... ) S.rindex(sub[, start[, end]]) -> int Return the highest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Raises ValueError when the substring is not found.","title":"rindex"},{"location":"api/tifeatures/layer/#rjust","text":"def rjust ( self , width , fillchar = ' ' , / ) Return a right-justified string of length width. Padding is done using the specified fill character (default is a space).","title":"rjust"},{"location":"api/tifeatures/layer/#rpartition","text":"def rpartition ( self , sep , / ) Partition the string into three parts using the given separator. This will search for the separator in the string, starting at the end. If the separator is found, returns a 3-tuple containing the part before the separator, the separator itself, and the part after it. If the separator is not found, returns a 3-tuple containing two empty strings and the original string.","title":"rpartition"},{"location":"api/tifeatures/layer/#rsplit","text":"def rsplit ( self , / , sep = None , maxsplit =- 1 ) Return a list of the words in the string, using sep as the delimiter string. sep The delimiter according which to split the string. None (the default value) means split according to any whitespace, and discard empty strings from the result. maxsplit Maximum number of splits to do. -1 (the default value) means no limit. Splits are done starting at the end of the string and working to the front.","title":"rsplit"},{"location":"api/tifeatures/layer/#rstrip","text":"def rstrip ( self , chars = None , / ) Return a copy of the string with trailing whitespace removed. If chars is given and not None, remove characters in chars instead.","title":"rstrip"},{"location":"api/tifeatures/layer/#split","text":"def split ( self , / , sep = None , maxsplit =- 1 ) Return a list of the words in the string, using sep as the delimiter string. sep The delimiter according which to split the string. None (the default value) means split according to any whitespace, and discard empty strings from the result. maxsplit Maximum number of splits to do. -1 (the default value) means no limit.","title":"split"},{"location":"api/tifeatures/layer/#splitlines","text":"def splitlines ( self , / , keepends = False ) Return a list of the lines in the string, breaking at line boundaries. Line breaks are not included in the resulting list unless keepends is given and true.","title":"splitlines"},{"location":"api/tifeatures/layer/#startswith","text":"def startswith ( ... ) S.startswith(prefix[, start[, end]]) -> bool Return True if S starts with the specified prefix, False otherwise. With optional start, test S beginning at that position. With optional end, stop comparing S at that position. prefix can also be a tuple of strings to try.","title":"startswith"},{"location":"api/tifeatures/layer/#strip","text":"def strip ( self , chars = None , / ) Return a copy of the string with leading and trailing whitespace removed. If chars is given and not None, remove characters in chars instead.","title":"strip"},{"location":"api/tifeatures/layer/#swapcase","text":"def swapcase ( self , / ) Convert uppercase characters to lowercase and lowercase characters to uppercase.","title":"swapcase"},{"location":"api/tifeatures/layer/#title","text":"def title ( self , / ) Return a version of the string where each word is titlecased. More specifically, words start with uppercased characters and all remaining cased characters have lower case.","title":"title"},{"location":"api/tifeatures/layer/#translate","text":"def translate ( self , table , / ) Replace each character in the string using the given translation table. table Translation table, which must be a mapping of Unicode ordinals to Unicode ordinals, strings, or None. The table must implement lookup/indexing via getitem , for instance a dictionary or list. If this operation raises LookupError, the character is left untouched. Characters mapped to None are deleted.","title":"translate"},{"location":"api/tifeatures/layer/#upper","text":"def upper ( self , / ) Return a copy of the string converted to uppercase.","title":"upper"},{"location":"api/tifeatures/layer/#zfill","text":"def zfill ( self , width , / ) Pad a numeric string with zeros on the left, to fill a field of the given width. The string is never truncated.","title":"zfill"},{"location":"api/tifeatures/layer/#table","text":"class Table ( __pydantic_self__ , ** data : Any )","title":"Table"},{"location":"api/tifeatures/layer/#attributes_1","text":"Name Type Description Default id str Layer's name. None bounds list Layer's bounds (left, bottom, right, top). None crs str Coordinate reference system of the Table. None type str Layer's type. None schema str Table's database schema (e.g public). None geometry_type str Table's geometry type (e.g polygon). None srid int Table's SRID None geometry_column str Name of the geomtry column in the table. None properties Dict Properties available in the table. None","title":"Attributes"},{"location":"api/tifeatures/layer/#ancestors-in-mro_4","text":"tifeatures.layer.CollectionLayer tifeatures.dbmodel.Table pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/layer/#class-variables_1","text":"Config","title":"Class variables"},{"location":"api/tifeatures/layer/#static-methods_2","text":"","title":"Static methods"},{"location":"api/tifeatures/layer/#bounds_default","text":"def bounds_default ( values ) Get default bounds from the first geometry columns.","title":"bounds_default"},{"location":"api/tifeatures/layer/#construct_1","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"api/tifeatures/layer/#from_orm_1","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"api/tifeatures/layer/#parse_file_1","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"api/tifeatures/layer/#parse_obj_1","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"api/tifeatures/layer/#parse_raw_1","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"api/tifeatures/layer/#schema_1","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"api/tifeatures/layer/#schema_json_1","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"api/tifeatures/layer/#update_forward_refs_1","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"api/tifeatures/layer/#validate_1","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"api/tifeatures/layer/#instance-variables_2","text":"id_column_info Return Column for a unique identifier. queryables Return the queryables.","title":"Instance variables"},{"location":"api/tifeatures/layer/#methods_4","text":"","title":"Methods"},{"location":"api/tifeatures/layer/#columns","text":"def columns ( self , properties : Union [ List [ str ], NoneType ] = None ) -> List [ str ] Return table columns optionally filtered to only include columns from properties.","title":"columns"},{"location":"api/tifeatures/layer/#copy_3","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"api/tifeatures/layer/#dict_1","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"api/tifeatures/layer/#features_1","text":"def features ( self , pool : buildpg . asyncpg . BuildPgPool , * , ids_filter : Union [ List [ str ], NoneType ] = None , bbox_filter : Union [ List [ float ], NoneType ] = None , datetime_filter : Union [ List [ str ], NoneType ] = None , properties_filter : Union [ List [ Tuple [ str , str ]], NoneType ] = None , cql_filter : Union [ ForwardRef ( 'Node' ), pygeofilter . values . Geometry , pygeofilter . values . Envelope , datetime . date , datetime . datetime , datetime . timedelta , pygeofilter . values . Interval , bool , float , int , str , list , NoneType ] = None , sortby : Union [ str , NoneType ] = None , properties : Union [ List [ str ], NoneType ] = None , geom : Union [ str , NoneType ] = None , dt : Union [ str , NoneType ] = None , limit : Union [ int , NoneType ] = None , offset : Union [ int , NoneType ] = None , bbox_only : Union [ bool , NoneType ] = None , simplify : Union [ float , NoneType ] = None , geom_as_wkt : bool = False ) -> Tuple [ tifeatures . layer . FeatureCollection , int ] Build and run Pg query.","title":"features"},{"location":"api/tifeatures/layer/#get_column","text":"def get_column ( self , property_name : str ) -> Union [ tifeatures . dbmodel . Column , NoneType ] Return column info.","title":"get_column"},{"location":"api/tifeatures/layer/#get_datetime_column","text":"def get_datetime_column ( self , name : Union [ str , NoneType ] = None ) -> Union [ tifeatures . dbmodel . Column , NoneType ] Return the Column for either the passed in tstz column or the first tstz column.","title":"get_datetime_column"},{"location":"api/tifeatures/layer/#get_geometry_column","text":"def get_geometry_column ( self , name : Union [ str , NoneType ] = None ) -> Union [ tifeatures . dbmodel . GeometryColumn , NoneType ] Return the name of the first geometry column.","title":"get_geometry_column"},{"location":"api/tifeatures/layer/#json_1","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"api/tifeatures/middleware/","text":"Module tifeatures.middleware \u00b6 tifeatures middlewares. None Classes \u00b6 CacheControlMiddleware \u00b6 class CacheControlMiddleware ( app : Callable [[ MutableMapping [ str , Any ], Callable [[], Awaitable [ MutableMapping [ str , Any ]]], Callable [[ MutableMapping [ str , Any ]], Awaitable [ NoneType ]]], Awaitable [ NoneType ]], cachecontrol : Union [ str , NoneType ] = None , exclude_path : Union [ Set [ str ], NoneType ] = None ) Ancestors (in MRO) \u00b6 starlette.middleware.base.BaseHTTPMiddleware Methods \u00b6 dispatch \u00b6 def dispatch ( self , request : starlette . requests . Request , call_next ) Add cache-control.","title":"middleware"},{"location":"api/tifeatures/middleware/#module-tifeaturesmiddleware","text":"tifeatures middlewares. None","title":"Module tifeatures.middleware"},{"location":"api/tifeatures/middleware/#classes","text":"","title":"Classes"},{"location":"api/tifeatures/middleware/#cachecontrolmiddleware","text":"class CacheControlMiddleware ( app : Callable [[ MutableMapping [ str , Any ], Callable [[], Awaitable [ MutableMapping [ str , Any ]]], Callable [[ MutableMapping [ str , Any ]], Awaitable [ NoneType ]]], Awaitable [ NoneType ]], cachecontrol : Union [ str , NoneType ] = None , exclude_path : Union [ Set [ str ], NoneType ] = None )","title":"CacheControlMiddleware"},{"location":"api/tifeatures/middleware/#ancestors-in-mro","text":"starlette.middleware.base.BaseHTTPMiddleware","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/middleware/#methods","text":"","title":"Methods"},{"location":"api/tifeatures/middleware/#dispatch","text":"def dispatch ( self , request : starlette . requests . Request , call_next ) Add cache-control.","title":"dispatch"},{"location":"api/tifeatures/model/","text":"Module tifeatures.model \u00b6 tifeatures models. None Classes \u00b6 Collection \u00b6 class Collection ( __pydantic_self__ , ** data : Any ) Ancestors (in MRO) \u00b6 pydantic.main.BaseModel pydantic.utils.Representation Class variables \u00b6 Config Static methods \u00b6 construct \u00b6 def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm \u00b6 def from_orm ( obj : Any ) -> 'Model' parse_file \u00b6 def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj \u00b6 def parse_obj ( obj : Any ) -> 'Model' parse_raw \u00b6 def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema \u00b6 def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json \u00b6 def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs \u00b6 def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate \u00b6 def validate ( value : Any ) -> 'Model' Methods \u00b6 copy \u00b6 def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict \u00b6 def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json \u00b6 def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Collections \u00b6 class Collections ( __pydantic_self__ , ** data : Any ) Ancestors (in MRO) \u00b6 pydantic.main.BaseModel pydantic.utils.Representation Class variables \u00b6 Config Static methods \u00b6 construct \u00b6 def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm \u00b6 def from_orm ( obj : Any ) -> 'Model' parse_file \u00b6 def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj \u00b6 def parse_obj ( obj : Any ) -> 'Model' parse_raw \u00b6 def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema \u00b6 def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json \u00b6 def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs \u00b6 def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate \u00b6 def validate ( value : Any ) -> 'Model' Methods \u00b6 copy \u00b6 def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict \u00b6 def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json \u00b6 def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Conformance \u00b6 class Conformance ( __pydantic_self__ , ** data : Any ) Ancestors (in MRO) \u00b6 pydantic.main.BaseModel pydantic.utils.Representation Class variables \u00b6 Config Static methods \u00b6 construct \u00b6 def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm \u00b6 def from_orm ( obj : Any ) -> 'Model' parse_file \u00b6 def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj \u00b6 def parse_obj ( obj : Any ) -> 'Model' parse_raw \u00b6 def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema \u00b6 def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json \u00b6 def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs \u00b6 def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate \u00b6 def validate ( value : Any ) -> 'Model' Methods \u00b6 copy \u00b6 def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict \u00b6 def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json \u00b6 def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Extent \u00b6 class Extent ( __pydantic_self__ , ** data : Any ) Ancestors (in MRO) \u00b6 pydantic.main.BaseModel pydantic.utils.Representation Class variables \u00b6 Config Static methods \u00b6 construct \u00b6 def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm \u00b6 def from_orm ( obj : Any ) -> 'Model' parse_file \u00b6 def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj \u00b6 def parse_obj ( obj : Any ) -> 'Model' parse_raw \u00b6 def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema \u00b6 def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json \u00b6 def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs \u00b6 def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate \u00b6 def validate ( value : Any ) -> 'Model' Methods \u00b6 copy \u00b6 def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict \u00b6 def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json \u00b6 def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Item \u00b6 class Item ( __pydantic_self__ , ** data : Any ) Ancestors (in MRO) \u00b6 geojson_pydantic.features.Feature pydantic.generics.GenericModel pydantic.main.BaseModel pydantic.utils.Representation typing.Generic geojson_pydantic.geometries.GeoInterfaceMixin Class variables \u00b6 Config Static methods \u00b6 construct \u00b6 def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm \u00b6 def from_orm ( obj : Any ) -> 'Model' parse_file \u00b6 def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj \u00b6 def parse_obj ( obj : Any ) -> 'Model' parse_raw \u00b6 def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema \u00b6 def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json \u00b6 def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' set_geometry \u00b6 def set_geometry ( v ) set geometry from geo interface or input update_forward_refs \u00b6 def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate \u00b6 def validate ( value ) Validate input. Methods \u00b6 copy \u00b6 def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict \u00b6 def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json \u00b6 def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Items \u00b6 class Items ( __pydantic_self__ , ** data : Any ) Ancestors (in MRO) \u00b6 geojson_pydantic.features.FeatureCollection pydantic.generics.GenericModel pydantic.main.BaseModel pydantic.utils.Representation typing.Generic geojson_pydantic.geometries.GeoInterfaceMixin Class variables \u00b6 Config Static methods \u00b6 construct \u00b6 def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm \u00b6 def from_orm ( obj : Any ) -> 'Model' parse_file \u00b6 def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj \u00b6 def parse_obj ( obj : Any ) -> 'Model' parse_raw \u00b6 def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema \u00b6 def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json \u00b6 def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs \u00b6 def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate \u00b6 def validate ( value ) Validate input. Methods \u00b6 copy \u00b6 def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict \u00b6 def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json \u00b6 def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . json_seq \u00b6 def json_seq ( self , ** kwargs ) return a GeoJSON sequence representation. Landing \u00b6 class Landing ( __pydantic_self__ , ** data : Any ) Ancestors (in MRO) \u00b6 pydantic.main.BaseModel pydantic.utils.Representation Class variables \u00b6 Config Static methods \u00b6 construct \u00b6 def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm \u00b6 def from_orm ( obj : Any ) -> 'Model' parse_file \u00b6 def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj \u00b6 def parse_obj ( obj : Any ) -> 'Model' parse_raw \u00b6 def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema \u00b6 def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json \u00b6 def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs \u00b6 def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate \u00b6 def validate ( value : Any ) -> 'Model' Methods \u00b6 copy \u00b6 def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict \u00b6 def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json \u00b6 def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Link \u00b6 class Link ( __pydantic_self__ , ** data : Any ) Ancestors (in MRO) \u00b6 pydantic.main.BaseModel pydantic.utils.Representation Class variables \u00b6 Config Static methods \u00b6 construct \u00b6 def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm \u00b6 def from_orm ( obj : Any ) -> 'Model' parse_file \u00b6 def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj \u00b6 def parse_obj ( obj : Any ) -> 'Model' parse_raw \u00b6 def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema \u00b6 def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json \u00b6 def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs \u00b6 def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate \u00b6 def validate ( value : Any ) -> 'Model' Methods \u00b6 copy \u00b6 def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict \u00b6 def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json \u00b6 def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Queryables \u00b6 class Queryables ( __pydantic_self__ , ** data : Any ) Ancestors (in MRO) \u00b6 pydantic.main.BaseModel pydantic.utils.Representation Class variables \u00b6 Config Static methods \u00b6 construct \u00b6 def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm \u00b6 def from_orm ( obj : Any ) -> 'Model' parse_file \u00b6 def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj \u00b6 def parse_obj ( obj : Any ) -> 'Model' parse_raw \u00b6 def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema \u00b6 def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json \u00b6 def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs \u00b6 def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate \u00b6 def validate ( value : Any ) -> 'Model' Methods \u00b6 copy \u00b6 def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict \u00b6 def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json \u00b6 def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Spatial \u00b6 class Spatial ( __pydantic_self__ , ** data : Any ) Ancestors (in MRO) \u00b6 pydantic.main.BaseModel pydantic.utils.Representation Class variables \u00b6 Config Static methods \u00b6 construct \u00b6 def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm \u00b6 def from_orm ( obj : Any ) -> 'Model' parse_file \u00b6 def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj \u00b6 def parse_obj ( obj : Any ) -> 'Model' parse_raw \u00b6 def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema \u00b6 def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json \u00b6 def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs \u00b6 def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate \u00b6 def validate ( value : Any ) -> 'Model' Methods \u00b6 copy \u00b6 def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict \u00b6 def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json \u00b6 def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Temporal \u00b6 class Temporal ( __pydantic_self__ , ** data : Any ) Ancestors (in MRO) \u00b6 pydantic.main.BaseModel pydantic.utils.Representation Class variables \u00b6 Config Static methods \u00b6 construct \u00b6 def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm \u00b6 def from_orm ( obj : Any ) -> 'Model' parse_file \u00b6 def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj \u00b6 def parse_obj ( obj : Any ) -> 'Model' parse_raw \u00b6 def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema \u00b6 def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json \u00b6 def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs \u00b6 def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate \u00b6 def validate ( value : Any ) -> 'Model' Methods \u00b6 copy \u00b6 def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict \u00b6 def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json \u00b6 def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"model"},{"location":"api/tifeatures/model/#module-tifeaturesmodel","text":"tifeatures models. None","title":"Module tifeatures.model"},{"location":"api/tifeatures/model/#classes","text":"","title":"Classes"},{"location":"api/tifeatures/model/#collection","text":"class Collection ( __pydantic_self__ , ** data : Any )","title":"Collection"},{"location":"api/tifeatures/model/#ancestors-in-mro","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/model/#class-variables","text":"Config","title":"Class variables"},{"location":"api/tifeatures/model/#static-methods","text":"","title":"Static methods"},{"location":"api/tifeatures/model/#construct","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"api/tifeatures/model/#from_orm","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"api/tifeatures/model/#parse_file","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"api/tifeatures/model/#parse_obj","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"api/tifeatures/model/#parse_raw","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"api/tifeatures/model/#schema","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"api/tifeatures/model/#schema_json","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"api/tifeatures/model/#update_forward_refs","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"api/tifeatures/model/#validate","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"api/tifeatures/model/#methods","text":"","title":"Methods"},{"location":"api/tifeatures/model/#copy","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"api/tifeatures/model/#dict","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"api/tifeatures/model/#json","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"api/tifeatures/model/#collections","text":"class Collections ( __pydantic_self__ , ** data : Any )","title":"Collections"},{"location":"api/tifeatures/model/#ancestors-in-mro_1","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/model/#class-variables_1","text":"Config","title":"Class variables"},{"location":"api/tifeatures/model/#static-methods_1","text":"","title":"Static methods"},{"location":"api/tifeatures/model/#construct_1","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"api/tifeatures/model/#from_orm_1","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"api/tifeatures/model/#parse_file_1","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"api/tifeatures/model/#parse_obj_1","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"api/tifeatures/model/#parse_raw_1","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"api/tifeatures/model/#schema_1","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"api/tifeatures/model/#schema_json_1","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"api/tifeatures/model/#update_forward_refs_1","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"api/tifeatures/model/#validate_1","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"api/tifeatures/model/#methods_1","text":"","title":"Methods"},{"location":"api/tifeatures/model/#copy_1","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"api/tifeatures/model/#dict_1","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"api/tifeatures/model/#json_1","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"api/tifeatures/model/#conformance","text":"class Conformance ( __pydantic_self__ , ** data : Any )","title":"Conformance"},{"location":"api/tifeatures/model/#ancestors-in-mro_2","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/model/#class-variables_2","text":"Config","title":"Class variables"},{"location":"api/tifeatures/model/#static-methods_2","text":"","title":"Static methods"},{"location":"api/tifeatures/model/#construct_2","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"api/tifeatures/model/#from_orm_2","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"api/tifeatures/model/#parse_file_2","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"api/tifeatures/model/#parse_obj_2","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"api/tifeatures/model/#parse_raw_2","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"api/tifeatures/model/#schema_2","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"api/tifeatures/model/#schema_json_2","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"api/tifeatures/model/#update_forward_refs_2","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"api/tifeatures/model/#validate_2","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"api/tifeatures/model/#methods_2","text":"","title":"Methods"},{"location":"api/tifeatures/model/#copy_2","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"api/tifeatures/model/#dict_2","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"api/tifeatures/model/#json_2","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"api/tifeatures/model/#extent","text":"class Extent ( __pydantic_self__ , ** data : Any )","title":"Extent"},{"location":"api/tifeatures/model/#ancestors-in-mro_3","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/model/#class-variables_3","text":"Config","title":"Class variables"},{"location":"api/tifeatures/model/#static-methods_3","text":"","title":"Static methods"},{"location":"api/tifeatures/model/#construct_3","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"api/tifeatures/model/#from_orm_3","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"api/tifeatures/model/#parse_file_3","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"api/tifeatures/model/#parse_obj_3","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"api/tifeatures/model/#parse_raw_3","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"api/tifeatures/model/#schema_3","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"api/tifeatures/model/#schema_json_3","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"api/tifeatures/model/#update_forward_refs_3","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"api/tifeatures/model/#validate_3","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"api/tifeatures/model/#methods_3","text":"","title":"Methods"},{"location":"api/tifeatures/model/#copy_3","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"api/tifeatures/model/#dict_3","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"api/tifeatures/model/#json_3","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"api/tifeatures/model/#item","text":"class Item ( __pydantic_self__ , ** data : Any )","title":"Item"},{"location":"api/tifeatures/model/#ancestors-in-mro_4","text":"geojson_pydantic.features.Feature pydantic.generics.GenericModel pydantic.main.BaseModel pydantic.utils.Representation typing.Generic geojson_pydantic.geometries.GeoInterfaceMixin","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/model/#class-variables_4","text":"Config","title":"Class variables"},{"location":"api/tifeatures/model/#static-methods_4","text":"","title":"Static methods"},{"location":"api/tifeatures/model/#construct_4","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"api/tifeatures/model/#from_orm_4","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"api/tifeatures/model/#parse_file_4","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"api/tifeatures/model/#parse_obj_4","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"api/tifeatures/model/#parse_raw_4","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"api/tifeatures/model/#schema_4","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"api/tifeatures/model/#schema_json_4","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"api/tifeatures/model/#set_geometry","text":"def set_geometry ( v ) set geometry from geo interface or input","title":"set_geometry"},{"location":"api/tifeatures/model/#update_forward_refs_4","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"api/tifeatures/model/#validate_4","text":"def validate ( value ) Validate input.","title":"validate"},{"location":"api/tifeatures/model/#methods_4","text":"","title":"Methods"},{"location":"api/tifeatures/model/#copy_4","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"api/tifeatures/model/#dict_4","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"api/tifeatures/model/#json_4","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"api/tifeatures/model/#items","text":"class Items ( __pydantic_self__ , ** data : Any )","title":"Items"},{"location":"api/tifeatures/model/#ancestors-in-mro_5","text":"geojson_pydantic.features.FeatureCollection pydantic.generics.GenericModel pydantic.main.BaseModel pydantic.utils.Representation typing.Generic geojson_pydantic.geometries.GeoInterfaceMixin","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/model/#class-variables_5","text":"Config","title":"Class variables"},{"location":"api/tifeatures/model/#static-methods_5","text":"","title":"Static methods"},{"location":"api/tifeatures/model/#construct_5","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"api/tifeatures/model/#from_orm_5","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"api/tifeatures/model/#parse_file_5","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"api/tifeatures/model/#parse_obj_5","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"api/tifeatures/model/#parse_raw_5","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"api/tifeatures/model/#schema_5","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"api/tifeatures/model/#schema_json_5","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"api/tifeatures/model/#update_forward_refs_5","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"api/tifeatures/model/#validate_5","text":"def validate ( value ) Validate input.","title":"validate"},{"location":"api/tifeatures/model/#methods_5","text":"","title":"Methods"},{"location":"api/tifeatures/model/#copy_5","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"api/tifeatures/model/#dict_5","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"api/tifeatures/model/#json_5","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"api/tifeatures/model/#json_seq","text":"def json_seq ( self , ** kwargs ) return a GeoJSON sequence representation.","title":"json_seq"},{"location":"api/tifeatures/model/#landing","text":"class Landing ( __pydantic_self__ , ** data : Any )","title":"Landing"},{"location":"api/tifeatures/model/#ancestors-in-mro_6","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/model/#class-variables_6","text":"Config","title":"Class variables"},{"location":"api/tifeatures/model/#static-methods_6","text":"","title":"Static methods"},{"location":"api/tifeatures/model/#construct_6","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"api/tifeatures/model/#from_orm_6","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"api/tifeatures/model/#parse_file_6","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"api/tifeatures/model/#parse_obj_6","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"api/tifeatures/model/#parse_raw_6","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"api/tifeatures/model/#schema_6","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"api/tifeatures/model/#schema_json_6","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"api/tifeatures/model/#update_forward_refs_6","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"api/tifeatures/model/#validate_6","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"api/tifeatures/model/#methods_6","text":"","title":"Methods"},{"location":"api/tifeatures/model/#copy_6","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"api/tifeatures/model/#dict_6","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"api/tifeatures/model/#json_6","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"api/tifeatures/model/#link","text":"class Link ( __pydantic_self__ , ** data : Any )","title":"Link"},{"location":"api/tifeatures/model/#ancestors-in-mro_7","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/model/#class-variables_7","text":"Config","title":"Class variables"},{"location":"api/tifeatures/model/#static-methods_7","text":"","title":"Static methods"},{"location":"api/tifeatures/model/#construct_7","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"api/tifeatures/model/#from_orm_7","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"api/tifeatures/model/#parse_file_7","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"api/tifeatures/model/#parse_obj_7","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"api/tifeatures/model/#parse_raw_7","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"api/tifeatures/model/#schema_7","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"api/tifeatures/model/#schema_json_7","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"api/tifeatures/model/#update_forward_refs_7","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"api/tifeatures/model/#validate_7","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"api/tifeatures/model/#methods_7","text":"","title":"Methods"},{"location":"api/tifeatures/model/#copy_7","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"api/tifeatures/model/#dict_7","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"api/tifeatures/model/#json_7","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"api/tifeatures/model/#queryables","text":"class Queryables ( __pydantic_self__ , ** data : Any )","title":"Queryables"},{"location":"api/tifeatures/model/#ancestors-in-mro_8","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/model/#class-variables_8","text":"Config","title":"Class variables"},{"location":"api/tifeatures/model/#static-methods_8","text":"","title":"Static methods"},{"location":"api/tifeatures/model/#construct_8","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"api/tifeatures/model/#from_orm_8","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"api/tifeatures/model/#parse_file_8","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"api/tifeatures/model/#parse_obj_8","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"api/tifeatures/model/#parse_raw_8","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"api/tifeatures/model/#schema_8","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"api/tifeatures/model/#schema_json_8","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"api/tifeatures/model/#update_forward_refs_8","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"api/tifeatures/model/#validate_8","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"api/tifeatures/model/#methods_8","text":"","title":"Methods"},{"location":"api/tifeatures/model/#copy_8","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"api/tifeatures/model/#dict_8","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"api/tifeatures/model/#json_8","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"api/tifeatures/model/#spatial","text":"class Spatial ( __pydantic_self__ , ** data : Any )","title":"Spatial"},{"location":"api/tifeatures/model/#ancestors-in-mro_9","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/model/#class-variables_9","text":"Config","title":"Class variables"},{"location":"api/tifeatures/model/#static-methods_9","text":"","title":"Static methods"},{"location":"api/tifeatures/model/#construct_9","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"api/tifeatures/model/#from_orm_9","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"api/tifeatures/model/#parse_file_9","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"api/tifeatures/model/#parse_obj_9","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"api/tifeatures/model/#parse_raw_9","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"api/tifeatures/model/#schema_9","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"api/tifeatures/model/#schema_json_9","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"api/tifeatures/model/#update_forward_refs_9","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"api/tifeatures/model/#validate_9","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"api/tifeatures/model/#methods_9","text":"","title":"Methods"},{"location":"api/tifeatures/model/#copy_9","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"api/tifeatures/model/#dict_9","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"api/tifeatures/model/#json_9","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"api/tifeatures/model/#temporal","text":"class Temporal ( __pydantic_self__ , ** data : Any )","title":"Temporal"},{"location":"api/tifeatures/model/#ancestors-in-mro_10","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/model/#class-variables_10","text":"Config","title":"Class variables"},{"location":"api/tifeatures/model/#static-methods_10","text":"","title":"Static methods"},{"location":"api/tifeatures/model/#construct_10","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"api/tifeatures/model/#from_orm_10","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"api/tifeatures/model/#parse_file_10","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"api/tifeatures/model/#parse_obj_10","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"api/tifeatures/model/#parse_raw_10","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"api/tifeatures/model/#schema_10","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"api/tifeatures/model/#schema_json_10","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"api/tifeatures/model/#update_forward_refs_10","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"api/tifeatures/model/#validate_10","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"api/tifeatures/model/#methods_10","text":"","title":"Methods"},{"location":"api/tifeatures/model/#copy_10","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"api/tifeatures/model/#dict_10","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"api/tifeatures/model/#json_10","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"api/tifeatures/settings/","text":"Module tifeatures.settings \u00b6 tifeatures config. None Functions \u00b6 APISettings \u00b6 def APISettings ( ) -> tifeatures . settings . _APISettings This function returns a cached instance of the Settings object. Classes \u00b6 PostgresSettings \u00b6 class PostgresSettings ( __pydantic_self__ , _env_file : Union [ str , os . PathLike , List [ Union [ str , os . PathLike ]], Tuple [ Union [ str , os . PathLike ], ... ], NoneType ] = '<object object at 0x7fce30823b90>' , _env_file_encoding : Union [ str , NoneType ] = None , _env_nested_delimiter : Union [ str , NoneType ] = None , _secrets_dir : Union [ str , os . PathLike , NoneType ] = None , ** values : Any ) Attributes \u00b6 Name Type Description Default postgres_user None postgres username. None postgres_pass None postgres password. None postgres_host None hostname for the connection. None postgres_port None database port. None postgres_dbname None database name. None Ancestors (in MRO) \u00b6 pydantic.env_settings.BaseSettings pydantic.main.BaseModel pydantic.utils.Representation Class variables \u00b6 Config Static methods \u00b6 assemble_db_connection \u00b6 def assemble_db_connection ( v : Union [ str , NoneType ], values : Dict [ str , Any ] ) -> Any Validate db url settings. construct \u00b6 def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm \u00b6 def from_orm ( obj : Any ) -> 'Model' parse_file \u00b6 def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj \u00b6 def parse_obj ( obj : Any ) -> 'Model' parse_raw \u00b6 def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema \u00b6 def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json \u00b6 def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs \u00b6 def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate \u00b6 def validate ( value : Any ) -> 'Model' Methods \u00b6 copy \u00b6 def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict \u00b6 def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json \u00b6 def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . TableConfig \u00b6 class TableConfig ( / , * args , ** kwargs ) Ancestors (in MRO) \u00b6 builtins.dict Methods \u00b6 clear \u00b6 def clear ( ... ) D.clear() -> None. Remove all items from D. copy \u00b6 def copy ( ... ) D.copy() -> a shallow copy of D fromkeys \u00b6 def fromkeys ( iterable , value = None , / ) Create a new dictionary with keys from iterable and values set to value. get \u00b6 def get ( self , key , default = None , / ) Return the value for key if key is in the dictionary, else default. items \u00b6 def items ( ... ) D.items() -> a set-like object providing a view on D's items keys \u00b6 def keys ( ... ) D.keys() -> a set-like object providing a view on D's keys pop \u00b6 def pop ( ... ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised popitem \u00b6 def popitem ( self , / ) Remove and return a (key, value) pair as a 2-tuple. Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the dict is empty. setdefault \u00b6 def setdefault ( self , key , default = None , / ) Insert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default. update \u00b6 def update ( ... ) D.update([E, ]**F) -> None. Update D from dict/iterable E and F. If E is present and has a .keys() method, then does: for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v In either case, this is followed by: for k in F: D[k] = F[k] values \u00b6 def values ( ... ) D.values() -> an object providing a view on D's values TableSettings \u00b6 class TableSettings ( __pydantic_self__ , _env_file : Union [ str , os . PathLike , List [ Union [ str , os . PathLike ]], Tuple [ Union [ str , os . PathLike ], ... ], NoneType ] = '<object object at 0x7fce30823b90>' , _env_file_encoding : Union [ str , NoneType ] = None , _env_nested_delimiter : Union [ str , NoneType ] = None , _secrets_dir : Union [ str , os . PathLike , NoneType ] = None , ** values : Any ) Ancestors (in MRO) \u00b6 pydantic.env_settings.BaseSettings pydantic.main.BaseModel pydantic.utils.Representation Class variables \u00b6 Config Static methods \u00b6 construct \u00b6 def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm \u00b6 def from_orm ( obj : Any ) -> 'Model' parse_file \u00b6 def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj \u00b6 def parse_obj ( obj : Any ) -> 'Model' parse_raw \u00b6 def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema \u00b6 def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json \u00b6 def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs \u00b6 def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate \u00b6 def validate ( value : Any ) -> 'Model' Methods \u00b6 copy \u00b6 def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict \u00b6 def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json \u00b6 def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"settings"},{"location":"api/tifeatures/settings/#module-tifeaturessettings","text":"tifeatures config. None","title":"Module tifeatures.settings"},{"location":"api/tifeatures/settings/#functions","text":"","title":"Functions"},{"location":"api/tifeatures/settings/#apisettings","text":"def APISettings ( ) -> tifeatures . settings . _APISettings This function returns a cached instance of the Settings object.","title":"APISettings"},{"location":"api/tifeatures/settings/#classes","text":"","title":"Classes"},{"location":"api/tifeatures/settings/#postgressettings","text":"class PostgresSettings ( __pydantic_self__ , _env_file : Union [ str , os . PathLike , List [ Union [ str , os . PathLike ]], Tuple [ Union [ str , os . PathLike ], ... ], NoneType ] = '<object object at 0x7fce30823b90>' , _env_file_encoding : Union [ str , NoneType ] = None , _env_nested_delimiter : Union [ str , NoneType ] = None , _secrets_dir : Union [ str , os . PathLike , NoneType ] = None , ** values : Any )","title":"PostgresSettings"},{"location":"api/tifeatures/settings/#attributes","text":"Name Type Description Default postgres_user None postgres username. None postgres_pass None postgres password. None postgres_host None hostname for the connection. None postgres_port None database port. None postgres_dbname None database name. None","title":"Attributes"},{"location":"api/tifeatures/settings/#ancestors-in-mro","text":"pydantic.env_settings.BaseSettings pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/settings/#class-variables","text":"Config","title":"Class variables"},{"location":"api/tifeatures/settings/#static-methods","text":"","title":"Static methods"},{"location":"api/tifeatures/settings/#assemble_db_connection","text":"def assemble_db_connection ( v : Union [ str , NoneType ], values : Dict [ str , Any ] ) -> Any Validate db url settings.","title":"assemble_db_connection"},{"location":"api/tifeatures/settings/#construct","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"api/tifeatures/settings/#from_orm","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"api/tifeatures/settings/#parse_file","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"api/tifeatures/settings/#parse_obj","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"api/tifeatures/settings/#parse_raw","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"api/tifeatures/settings/#schema","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"api/tifeatures/settings/#schema_json","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"api/tifeatures/settings/#update_forward_refs","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"api/tifeatures/settings/#validate","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"api/tifeatures/settings/#methods","text":"","title":"Methods"},{"location":"api/tifeatures/settings/#copy","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"api/tifeatures/settings/#dict","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"api/tifeatures/settings/#json","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"api/tifeatures/settings/#tableconfig","text":"class TableConfig ( / , * args , ** kwargs )","title":"TableConfig"},{"location":"api/tifeatures/settings/#ancestors-in-mro_1","text":"builtins.dict","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/settings/#methods_1","text":"","title":"Methods"},{"location":"api/tifeatures/settings/#clear","text":"def clear ( ... ) D.clear() -> None. Remove all items from D.","title":"clear"},{"location":"api/tifeatures/settings/#copy_1","text":"def copy ( ... ) D.copy() -> a shallow copy of D","title":"copy"},{"location":"api/tifeatures/settings/#fromkeys","text":"def fromkeys ( iterable , value = None , / ) Create a new dictionary with keys from iterable and values set to value.","title":"fromkeys"},{"location":"api/tifeatures/settings/#get","text":"def get ( self , key , default = None , / ) Return the value for key if key is in the dictionary, else default.","title":"get"},{"location":"api/tifeatures/settings/#items","text":"def items ( ... ) D.items() -> a set-like object providing a view on D's items","title":"items"},{"location":"api/tifeatures/settings/#keys","text":"def keys ( ... ) D.keys() -> a set-like object providing a view on D's keys","title":"keys"},{"location":"api/tifeatures/settings/#pop","text":"def pop ( ... ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised","title":"pop"},{"location":"api/tifeatures/settings/#popitem","text":"def popitem ( self , / ) Remove and return a (key, value) pair as a 2-tuple. Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the dict is empty.","title":"popitem"},{"location":"api/tifeatures/settings/#setdefault","text":"def setdefault ( self , key , default = None , / ) Insert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default.","title":"setdefault"},{"location":"api/tifeatures/settings/#update","text":"def update ( ... ) D.update([E, ]**F) -> None. Update D from dict/iterable E and F. If E is present and has a .keys() method, then does: for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v In either case, this is followed by: for k in F: D[k] = F[k]","title":"update"},{"location":"api/tifeatures/settings/#values","text":"def values ( ... ) D.values() -> an object providing a view on D's values","title":"values"},{"location":"api/tifeatures/settings/#tablesettings","text":"class TableSettings ( __pydantic_self__ , _env_file : Union [ str , os . PathLike , List [ Union [ str , os . PathLike ]], Tuple [ Union [ str , os . PathLike ], ... ], NoneType ] = '<object object at 0x7fce30823b90>' , _env_file_encoding : Union [ str , NoneType ] = None , _env_nested_delimiter : Union [ str , NoneType ] = None , _secrets_dir : Union [ str , os . PathLike , NoneType ] = None , ** values : Any )","title":"TableSettings"},{"location":"api/tifeatures/settings/#ancestors-in-mro_2","text":"pydantic.env_settings.BaseSettings pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/settings/#class-variables_1","text":"Config","title":"Class variables"},{"location":"api/tifeatures/settings/#static-methods_1","text":"","title":"Static methods"},{"location":"api/tifeatures/settings/#construct_1","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"api/tifeatures/settings/#from_orm_1","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"api/tifeatures/settings/#parse_file_1","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"api/tifeatures/settings/#parse_obj_1","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"api/tifeatures/settings/#parse_raw_1","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"api/tifeatures/settings/#schema_1","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"api/tifeatures/settings/#schema_json_1","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"api/tifeatures/settings/#update_forward_refs_1","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"api/tifeatures/settings/#validate_1","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"api/tifeatures/settings/#methods_2","text":"","title":"Methods"},{"location":"api/tifeatures/settings/#copy_2","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , update : Union [ ForwardRef ( 'DictStrAny' ), NoneType ] = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"api/tifeatures/settings/#dict_1","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"api/tifeatures/settings/#json_1","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' ), NoneType ] = None , by_alias : bool = False , skip_defaults : Union [ bool , NoneType ] = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"api/tifeatures/filter/evaluate/","text":"Module tifeatures.filter.evaluate \u00b6 tifeatures.filter.evaluate. None Variables \u00b6 LITERALS Functions \u00b6 to_filter \u00b6 def to_filter ( ast , field_mapping = None ) Helper function to translate ECQL AST to Django Query expressions. Parameters: Name Type Description Default ast None the abstract syntax tree None field_mapping None a dict mapping from the filter name to the Django field lookup. None mapping_choices None a dict mapping field lookups to choices. None Returns: Type Description None a Django query object Classes \u00b6 BuildPGEvaluator \u00b6 class BuildPGEvaluator ( field_mapping ) Ancestors (in MRO) \u00b6 pygeofilter.backends.evaluator.Evaluator Class variables \u00b6 handler_map Methods \u00b6 adopt \u00b6 def adopt ( self , node , * sub_args ) Interface function for a last resort when trying to evaluate a node and no handler was found. adopt_result \u00b6 def adopt_result ( self , result : Any ) -> Any Interface function for adopting the final evaluation result if necessary. Default is no-op. arithmetic \u00b6 def arithmetic ( self , node , lhs , rhs ) attribute \u00b6 def attribute ( self , node ) bbox \u00b6 def bbox ( self , node , lhs ) between \u00b6 def between ( self , node , lhs , low , high ) combination \u00b6 def combination ( self , node , lhs , rhs ) comparison \u00b6 def comparison ( self , node , lhs , rhs ) envelope \u00b6 def envelope ( self , node ) evaluate \u00b6 def evaluate ( self , node : Union [ ForwardRef ( 'Node' ), pygeofilter . values . Geometry , pygeofilter . values . Envelope , datetime . date , datetime . datetime , datetime . timedelta , pygeofilter . values . Interval , bool , float , int , str , list ], adopt_result : bool = True ) -> Any Recursive function to evaluate an abstract syntax tree. For every node in the walked syntax tree, its registered handler is called with the node as first parameter and all pre-evaluated child nodes as star-arguments. When no handler was found for a given node, the adopt function is called with the node and its arguments, which by default raises an NotImplementedError . function \u00b6 def function ( self , node , * arguments ) geometry \u00b6 def geometry ( self , node ) in_ \u00b6 def in_ ( self , node , lhs , * options ) interval \u00b6 def interval ( self , node , start , end ) like \u00b6 def like ( self , node , lhs ) literal \u00b6 def literal ( self , node ) not_ \u00b6 def not_ ( self , node , sub ) null \u00b6 def null ( self , node , lhs ) spatial_distance \u00b6 def spatial_distance ( self , node , lhs , rhs ) spatial_operation \u00b6 def spatial_operation ( self , node , lhs , rhs ) spatial_pattern \u00b6 def spatial_pattern ( self , node , lhs , rhs ) temporal \u00b6 def temporal ( self , node , lhs , rhs )","title":"evaluate"},{"location":"api/tifeatures/filter/evaluate/#module-tifeaturesfilterevaluate","text":"tifeatures.filter.evaluate. None","title":"Module tifeatures.filter.evaluate"},{"location":"api/tifeatures/filter/evaluate/#variables","text":"LITERALS","title":"Variables"},{"location":"api/tifeatures/filter/evaluate/#functions","text":"","title":"Functions"},{"location":"api/tifeatures/filter/evaluate/#to_filter","text":"def to_filter ( ast , field_mapping = None ) Helper function to translate ECQL AST to Django Query expressions. Parameters: Name Type Description Default ast None the abstract syntax tree None field_mapping None a dict mapping from the filter name to the Django field lookup. None mapping_choices None a dict mapping field lookups to choices. None Returns: Type Description None a Django query object","title":"to_filter"},{"location":"api/tifeatures/filter/evaluate/#classes","text":"","title":"Classes"},{"location":"api/tifeatures/filter/evaluate/#buildpgevaluator","text":"class BuildPGEvaluator ( field_mapping )","title":"BuildPGEvaluator"},{"location":"api/tifeatures/filter/evaluate/#ancestors-in-mro","text":"pygeofilter.backends.evaluator.Evaluator","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/filter/evaluate/#class-variables","text":"handler_map","title":"Class variables"},{"location":"api/tifeatures/filter/evaluate/#methods","text":"","title":"Methods"},{"location":"api/tifeatures/filter/evaluate/#adopt","text":"def adopt ( self , node , * sub_args ) Interface function for a last resort when trying to evaluate a node and no handler was found.","title":"adopt"},{"location":"api/tifeatures/filter/evaluate/#adopt_result","text":"def adopt_result ( self , result : Any ) -> Any Interface function for adopting the final evaluation result if necessary. Default is no-op.","title":"adopt_result"},{"location":"api/tifeatures/filter/evaluate/#arithmetic","text":"def arithmetic ( self , node , lhs , rhs )","title":"arithmetic"},{"location":"api/tifeatures/filter/evaluate/#attribute","text":"def attribute ( self , node )","title":"attribute"},{"location":"api/tifeatures/filter/evaluate/#bbox","text":"def bbox ( self , node , lhs )","title":"bbox"},{"location":"api/tifeatures/filter/evaluate/#between","text":"def between ( self , node , lhs , low , high )","title":"between"},{"location":"api/tifeatures/filter/evaluate/#combination","text":"def combination ( self , node , lhs , rhs )","title":"combination"},{"location":"api/tifeatures/filter/evaluate/#comparison","text":"def comparison ( self , node , lhs , rhs )","title":"comparison"},{"location":"api/tifeatures/filter/evaluate/#envelope","text":"def envelope ( self , node )","title":"envelope"},{"location":"api/tifeatures/filter/evaluate/#evaluate","text":"def evaluate ( self , node : Union [ ForwardRef ( 'Node' ), pygeofilter . values . Geometry , pygeofilter . values . Envelope , datetime . date , datetime . datetime , datetime . timedelta , pygeofilter . values . Interval , bool , float , int , str , list ], adopt_result : bool = True ) -> Any Recursive function to evaluate an abstract syntax tree. For every node in the walked syntax tree, its registered handler is called with the node as first parameter and all pre-evaluated child nodes as star-arguments. When no handler was found for a given node, the adopt function is called with the node and its arguments, which by default raises an NotImplementedError .","title":"evaluate"},{"location":"api/tifeatures/filter/evaluate/#function","text":"def function ( self , node , * arguments )","title":"function"},{"location":"api/tifeatures/filter/evaluate/#geometry","text":"def geometry ( self , node )","title":"geometry"},{"location":"api/tifeatures/filter/evaluate/#in_","text":"def in_ ( self , node , lhs , * options )","title":"in_"},{"location":"api/tifeatures/filter/evaluate/#interval","text":"def interval ( self , node , start , end )","title":"interval"},{"location":"api/tifeatures/filter/evaluate/#like","text":"def like ( self , node , lhs )","title":"like"},{"location":"api/tifeatures/filter/evaluate/#literal","text":"def literal ( self , node )","title":"literal"},{"location":"api/tifeatures/filter/evaluate/#not_","text":"def not_ ( self , node , sub )","title":"not_"},{"location":"api/tifeatures/filter/evaluate/#null","text":"def null ( self , node , lhs )","title":"null"},{"location":"api/tifeatures/filter/evaluate/#spatial_distance","text":"def spatial_distance ( self , node , lhs , rhs )","title":"spatial_distance"},{"location":"api/tifeatures/filter/evaluate/#spatial_operation","text":"def spatial_operation ( self , node , lhs , rhs )","title":"spatial_operation"},{"location":"api/tifeatures/filter/evaluate/#spatial_pattern","text":"def spatial_pattern ( self , node , lhs , rhs )","title":"spatial_pattern"},{"location":"api/tifeatures/filter/evaluate/#temporal","text":"def temporal ( self , node , lhs , rhs )","title":"temporal"},{"location":"api/tifeatures/filter/filters/","text":"Module tifeatures.filter.filters \u00b6 tifeatures.filter.filters None Variables \u00b6 UNITS_LOOKUP Functions \u00b6 attribute \u00b6 def attribute ( name : str , fields : List [ str ] ) Create an attribute lookup expression using a field mapping dictionary. Parameters: Name Type Description Default name None the field filter name None field_mapping None the dictionary to use as a lookup. None bbox \u00b6 def bbox ( lhs , minx , miny , maxx , maxy , crs : int = 4326 ) Create a bounding box filter for the given spatial attribute. Parameters: Name Type Description Default lhs None the field to compare None minx None the lower x part of the bbox None miny None the lower y part of the bbox None maxx None the upper x part of the bbox None maxy None the upper y part of the bbox None crs None the CRS the bbox is expressed in None Returns: Type Description None a comparison expression object bbox_to_wkt \u00b6 def bbox_to_wkt ( bbox : List [ float ], srid : int = 4326 ) -> str Return WKT representation of a BBOX. between \u00b6 def between ( lhs , low , high , negate = False ) Create a filter to match elements that have a value within a certain range. Parameters: Name Type Description Default lhs None the field to compare None low None the lower value of the range None high None the upper value of the range None not_ None whether the range shall be inclusive (the default) or exclusive None Returns: Type Description None a comparison expression object combine \u00b6 def combine ( sub_filters , combinator : str = 'AND' ) Combine filters using a logical combinator Parameters: Name Type Description Default sub_filters None the filters to combine None combinator None a string: \"AND\" / \"OR\" None Returns: Type Description None the combined filter func \u00b6 def func ( name , * args ) Return results of running SQL function with arguments. like \u00b6 def like ( lhs , rhs , case = False , negate = False ) Create a filter to filter elements according to a string attribute using wildcard expressions. Parameters: Name Type Description Default lhs None the field to compare None rhs None the wildcard pattern: a string containing any number of '%' characters as wildcards. None case None whether the lookup shall be done case sensitively or not None not_ None whether the range shall be inclusive (the default) or exclusive None Returns: Type Description None a comparison expression object literal \u00b6 def literal ( value ) literal value. negate \u00b6 def negate ( sub_filter ) Negate a filter, opposing its meaning. Parameters: Name Type Description Default sub_filter None the filter to negate None Returns: Type Description None the negated filter parse_geometry \u00b6 def parse_geometry ( geom : Dict [ str , Any ] ) -> str Parse geometry object and return WKT. quote_ident \u00b6 def quote_ident ( s : str ) -> str quote. runop \u00b6 def runop ( lhs , rhs = None , op : str = '=' , negate : bool = False ) Compare a filter with an expression using a comparison operation. Parameters: Name Type Description Default lhs None the field to compare None rhs None the filter expression None op None a string denoting the operation. None Returns: Type Description None a comparison expression object spatial \u00b6 def spatial ( lhs , rhs , op , pattern = None , distance = None , units = None ) Create a spatial filter for the given spatial attribute. Parameters: Name Type Description Default lhs None the field to compare None rhs None the time instant or time span to use as a filter None op None the comparison operation. one of \"INTERSECTS\" , \"DISJOINT\" , `\"CONTAINS\" , \"WITHIN\" , \"TOUCHES\" , \"CROSSES\" , \"OVERLAPS\" , \"EQUALS\" , \"RELATE\" , \"DWITHIN\" , \"BEYOND\"`` None pattern None the spatial relation pattern None distance None the distance value for distance based lookups: \"DWITHIN\" and \"BEYOND\" None units None the units the distance is expressed in None Returns: Type Description None a comparison expression object temporal \u00b6 def temporal ( lhs , time_or_period , op ) Create a temporal filter for the given temporal attribute. Parameters: Name Type Description Default lhs None the field to compare None time_or_period None the time instant or time span to use as a filter None op None the comparison operation. one of \"BEFORE\" , \"BEFORE OR DURING\" , \"DURING\" , \"DURING OR AFTER\" , \"AFTER\" . None Returns: Type Description None a comparison expression object Classes \u00b6 Operator \u00b6 class Operator ( operator : str = None ) Class variables \u00b6 OPERATORS","title":"filters"},{"location":"api/tifeatures/filter/filters/#module-tifeaturesfilterfilters","text":"tifeatures.filter.filters None","title":"Module tifeatures.filter.filters"},{"location":"api/tifeatures/filter/filters/#variables","text":"UNITS_LOOKUP","title":"Variables"},{"location":"api/tifeatures/filter/filters/#functions","text":"","title":"Functions"},{"location":"api/tifeatures/filter/filters/#attribute","text":"def attribute ( name : str , fields : List [ str ] ) Create an attribute lookup expression using a field mapping dictionary. Parameters: Name Type Description Default name None the field filter name None field_mapping None the dictionary to use as a lookup. None","title":"attribute"},{"location":"api/tifeatures/filter/filters/#bbox","text":"def bbox ( lhs , minx , miny , maxx , maxy , crs : int = 4326 ) Create a bounding box filter for the given spatial attribute. Parameters: Name Type Description Default lhs None the field to compare None minx None the lower x part of the bbox None miny None the lower y part of the bbox None maxx None the upper x part of the bbox None maxy None the upper y part of the bbox None crs None the CRS the bbox is expressed in None Returns: Type Description None a comparison expression object","title":"bbox"},{"location":"api/tifeatures/filter/filters/#bbox_to_wkt","text":"def bbox_to_wkt ( bbox : List [ float ], srid : int = 4326 ) -> str Return WKT representation of a BBOX.","title":"bbox_to_wkt"},{"location":"api/tifeatures/filter/filters/#between","text":"def between ( lhs , low , high , negate = False ) Create a filter to match elements that have a value within a certain range. Parameters: Name Type Description Default lhs None the field to compare None low None the lower value of the range None high None the upper value of the range None not_ None whether the range shall be inclusive (the default) or exclusive None Returns: Type Description None a comparison expression object","title":"between"},{"location":"api/tifeatures/filter/filters/#combine","text":"def combine ( sub_filters , combinator : str = 'AND' ) Combine filters using a logical combinator Parameters: Name Type Description Default sub_filters None the filters to combine None combinator None a string: \"AND\" / \"OR\" None Returns: Type Description None the combined filter","title":"combine"},{"location":"api/tifeatures/filter/filters/#func","text":"def func ( name , * args ) Return results of running SQL function with arguments.","title":"func"},{"location":"api/tifeatures/filter/filters/#like","text":"def like ( lhs , rhs , case = False , negate = False ) Create a filter to filter elements according to a string attribute using wildcard expressions. Parameters: Name Type Description Default lhs None the field to compare None rhs None the wildcard pattern: a string containing any number of '%' characters as wildcards. None case None whether the lookup shall be done case sensitively or not None not_ None whether the range shall be inclusive (the default) or exclusive None Returns: Type Description None a comparison expression object","title":"like"},{"location":"api/tifeatures/filter/filters/#literal","text":"def literal ( value ) literal value.","title":"literal"},{"location":"api/tifeatures/filter/filters/#negate","text":"def negate ( sub_filter ) Negate a filter, opposing its meaning. Parameters: Name Type Description Default sub_filter None the filter to negate None Returns: Type Description None the negated filter","title":"negate"},{"location":"api/tifeatures/filter/filters/#parse_geometry","text":"def parse_geometry ( geom : Dict [ str , Any ] ) -> str Parse geometry object and return WKT.","title":"parse_geometry"},{"location":"api/tifeatures/filter/filters/#quote_ident","text":"def quote_ident ( s : str ) -> str quote.","title":"quote_ident"},{"location":"api/tifeatures/filter/filters/#runop","text":"def runop ( lhs , rhs = None , op : str = '=' , negate : bool = False ) Compare a filter with an expression using a comparison operation. Parameters: Name Type Description Default lhs None the field to compare None rhs None the filter expression None op None a string denoting the operation. None Returns: Type Description None a comparison expression object","title":"runop"},{"location":"api/tifeatures/filter/filters/#spatial","text":"def spatial ( lhs , rhs , op , pattern = None , distance = None , units = None ) Create a spatial filter for the given spatial attribute. Parameters: Name Type Description Default lhs None the field to compare None rhs None the time instant or time span to use as a filter None op None the comparison operation. one of \"INTERSECTS\" , \"DISJOINT\" , `\"CONTAINS\" , \"WITHIN\" , \"TOUCHES\" , \"CROSSES\" , \"OVERLAPS\" , \"EQUALS\" , \"RELATE\" , \"DWITHIN\" , \"BEYOND\"`` None pattern None the spatial relation pattern None distance None the distance value for distance based lookups: \"DWITHIN\" and \"BEYOND\" None units None the units the distance is expressed in None Returns: Type Description None a comparison expression object","title":"spatial"},{"location":"api/tifeatures/filter/filters/#temporal","text":"def temporal ( lhs , time_or_period , op ) Create a temporal filter for the given temporal attribute. Parameters: Name Type Description Default lhs None the field to compare None time_or_period None the time instant or time span to use as a filter None op None the comparison operation. one of \"BEFORE\" , \"BEFORE OR DURING\" , \"DURING\" , \"DURING OR AFTER\" , \"AFTER\" . None Returns: Type Description None a comparison expression object","title":"temporal"},{"location":"api/tifeatures/filter/filters/#classes","text":"","title":"Classes"},{"location":"api/tifeatures/filter/filters/#operator","text":"class Operator ( operator : str = None )","title":"Operator"},{"location":"api/tifeatures/filter/filters/#class-variables","text":"OPERATORS","title":"Class variables"},{"location":"api/tifeatures/resources/enums/","text":"Module tifeatures.resources.enums \u00b6 tifeatures enums. None Classes \u00b6 FilterLang \u00b6 class FilterLang ( / , * args , ** kwargs ) Ancestors (in MRO) \u00b6 builtins.str enum.Enum Class variables \u00b6 cql2_json cql2_text name value ItemResponseType \u00b6 class ItemResponseType ( / , * args , ** kwargs ) Ancestors (in MRO) \u00b6 builtins.str enum.Enum Class variables \u00b6 geojson html json name value ItemsResponseType \u00b6 class ItemsResponseType ( / , * args , ** kwargs ) Ancestors (in MRO) \u00b6 builtins.str enum.Enum Class variables \u00b6 csv geojson geojsonseq html json name ndjson value MediaType \u00b6 class MediaType ( / , * args , ** kwargs ) Ancestors (in MRO) \u00b6 builtins.str enum.Enum Class variables \u00b6 csv geojson geojsonseq html json name ndjson openapi30_json openapi30_yaml schemajson text value xml QueryablesResponseType \u00b6 class QueryablesResponseType ( / , * args , ** kwargs ) Ancestors (in MRO) \u00b6 builtins.str enum.Enum Class variables \u00b6 html name schemajson value ResponseType \u00b6 class ResponseType ( / , * args , ** kwargs ) Ancestors (in MRO) \u00b6 builtins.str enum.Enum Class variables \u00b6 html json name value","title":"enums"},{"location":"api/tifeatures/resources/enums/#module-tifeaturesresourcesenums","text":"tifeatures enums. None","title":"Module tifeatures.resources.enums"},{"location":"api/tifeatures/resources/enums/#classes","text":"","title":"Classes"},{"location":"api/tifeatures/resources/enums/#filterlang","text":"class FilterLang ( / , * args , ** kwargs )","title":"FilterLang"},{"location":"api/tifeatures/resources/enums/#ancestors-in-mro","text":"builtins.str enum.Enum","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/resources/enums/#class-variables","text":"cql2_json cql2_text name value","title":"Class variables"},{"location":"api/tifeatures/resources/enums/#itemresponsetype","text":"class ItemResponseType ( / , * args , ** kwargs )","title":"ItemResponseType"},{"location":"api/tifeatures/resources/enums/#ancestors-in-mro_1","text":"builtins.str enum.Enum","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/resources/enums/#class-variables_1","text":"geojson html json name value","title":"Class variables"},{"location":"api/tifeatures/resources/enums/#itemsresponsetype","text":"class ItemsResponseType ( / , * args , ** kwargs )","title":"ItemsResponseType"},{"location":"api/tifeatures/resources/enums/#ancestors-in-mro_2","text":"builtins.str enum.Enum","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/resources/enums/#class-variables_2","text":"csv geojson geojsonseq html json name ndjson value","title":"Class variables"},{"location":"api/tifeatures/resources/enums/#mediatype","text":"class MediaType ( / , * args , ** kwargs )","title":"MediaType"},{"location":"api/tifeatures/resources/enums/#ancestors-in-mro_3","text":"builtins.str enum.Enum","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/resources/enums/#class-variables_3","text":"csv geojson geojsonseq html json name ndjson openapi30_json openapi30_yaml schemajson text value xml","title":"Class variables"},{"location":"api/tifeatures/resources/enums/#queryablesresponsetype","text":"class QueryablesResponseType ( / , * args , ** kwargs )","title":"QueryablesResponseType"},{"location":"api/tifeatures/resources/enums/#ancestors-in-mro_4","text":"builtins.str enum.Enum","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/resources/enums/#class-variables_4","text":"html name schemajson value","title":"Class variables"},{"location":"api/tifeatures/resources/enums/#responsetype","text":"class ResponseType ( / , * args , ** kwargs )","title":"ResponseType"},{"location":"api/tifeatures/resources/enums/#ancestors-in-mro_5","text":"builtins.str enum.Enum","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/resources/enums/#class-variables_5","text":"html json name value","title":"Class variables"},{"location":"api/tifeatures/resources/response/","text":"Module tifeatures.resources.response \u00b6 tifeatures custom responses. None Classes \u00b6 GeoJSONResponse \u00b6 class GeoJSONResponse ( content : Any , status_code : int = 200 , headers : Union [ Dict [ str , str ], NoneType ] = None , media_type : Union [ str , NoneType ] = None , background : Union [ starlette . background . BackgroundTask , NoneType ] = None ) Ancestors (in MRO) \u00b6 fastapi.responses.ORJSONResponse starlette.responses.JSONResponse starlette.responses.Response Class variables \u00b6 charset media_type Instance variables \u00b6 headers Methods \u00b6 delete_cookie \u00b6 def delete_cookie ( self , key : str , path : str = '/' , domain : Union [ str , NoneType ] = None , secure : bool = False , httponly : bool = False , samesite : Union [ Literal [ 'lax' , 'strict' , 'none' ], NoneType ] = 'lax' ) -> None init_headers \u00b6 def init_headers ( self , headers : Union [ Mapping [ str , str ], NoneType ] = None ) -> None render \u00b6 def render ( self , content : Any ) -> bytes set_cookie \u00b6 def set_cookie ( self , key : str , value : str = '' , max_age : Union [ int , NoneType ] = None , expires : Union [ int , NoneType ] = None , path : str = '/' , domain : Union [ str , NoneType ] = None , secure : bool = False , httponly : bool = False , samesite : Union [ Literal [ 'lax' , 'strict' , 'none' ], NoneType ] = 'lax' ) -> None SchemaJSONResponse \u00b6 class SchemaJSONResponse ( content : Any , status_code : int = 200 , headers : Union [ Dict [ str , str ], NoneType ] = None , media_type : Union [ str , NoneType ] = None , background : Union [ starlette . background . BackgroundTask , NoneType ] = None ) Ancestors (in MRO) \u00b6 fastapi.responses.ORJSONResponse starlette.responses.JSONResponse starlette.responses.Response Class variables \u00b6 charset media_type Instance variables \u00b6 headers Methods \u00b6 delete_cookie \u00b6 def delete_cookie ( self , key : str , path : str = '/' , domain : Union [ str , NoneType ] = None , secure : bool = False , httponly : bool = False , samesite : Union [ Literal [ 'lax' , 'strict' , 'none' ], NoneType ] = 'lax' ) -> None init_headers \u00b6 def init_headers ( self , headers : Union [ Mapping [ str , str ], NoneType ] = None ) -> None render \u00b6 def render ( self , content : Any ) -> bytes set_cookie \u00b6 def set_cookie ( self , key : str , value : str = '' , max_age : Union [ int , NoneType ] = None , expires : Union [ int , NoneType ] = None , path : str = '/' , domain : Union [ str , NoneType ] = None , secure : bool = False , httponly : bool = False , samesite : Union [ Literal [ 'lax' , 'strict' , 'none' ], NoneType ] = 'lax' ) -> None","title":"response"},{"location":"api/tifeatures/resources/response/#module-tifeaturesresourcesresponse","text":"tifeatures custom responses. None","title":"Module tifeatures.resources.response"},{"location":"api/tifeatures/resources/response/#classes","text":"","title":"Classes"},{"location":"api/tifeatures/resources/response/#geojsonresponse","text":"class GeoJSONResponse ( content : Any , status_code : int = 200 , headers : Union [ Dict [ str , str ], NoneType ] = None , media_type : Union [ str , NoneType ] = None , background : Union [ starlette . background . BackgroundTask , NoneType ] = None )","title":"GeoJSONResponse"},{"location":"api/tifeatures/resources/response/#ancestors-in-mro","text":"fastapi.responses.ORJSONResponse starlette.responses.JSONResponse starlette.responses.Response","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/resources/response/#class-variables","text":"charset media_type","title":"Class variables"},{"location":"api/tifeatures/resources/response/#instance-variables","text":"headers","title":"Instance variables"},{"location":"api/tifeatures/resources/response/#methods","text":"","title":"Methods"},{"location":"api/tifeatures/resources/response/#delete_cookie","text":"def delete_cookie ( self , key : str , path : str = '/' , domain : Union [ str , NoneType ] = None , secure : bool = False , httponly : bool = False , samesite : Union [ Literal [ 'lax' , 'strict' , 'none' ], NoneType ] = 'lax' ) -> None","title":"delete_cookie"},{"location":"api/tifeatures/resources/response/#init_headers","text":"def init_headers ( self , headers : Union [ Mapping [ str , str ], NoneType ] = None ) -> None","title":"init_headers"},{"location":"api/tifeatures/resources/response/#render","text":"def render ( self , content : Any ) -> bytes","title":"render"},{"location":"api/tifeatures/resources/response/#set_cookie","text":"def set_cookie ( self , key : str , value : str = '' , max_age : Union [ int , NoneType ] = None , expires : Union [ int , NoneType ] = None , path : str = '/' , domain : Union [ str , NoneType ] = None , secure : bool = False , httponly : bool = False , samesite : Union [ Literal [ 'lax' , 'strict' , 'none' ], NoneType ] = 'lax' ) -> None","title":"set_cookie"},{"location":"api/tifeatures/resources/response/#schemajsonresponse","text":"class SchemaJSONResponse ( content : Any , status_code : int = 200 , headers : Union [ Dict [ str , str ], NoneType ] = None , media_type : Union [ str , NoneType ] = None , background : Union [ starlette . background . BackgroundTask , NoneType ] = None )","title":"SchemaJSONResponse"},{"location":"api/tifeatures/resources/response/#ancestors-in-mro_1","text":"fastapi.responses.ORJSONResponse starlette.responses.JSONResponse starlette.responses.Response","title":"Ancestors (in MRO)"},{"location":"api/tifeatures/resources/response/#class-variables_1","text":"charset media_type","title":"Class variables"},{"location":"api/tifeatures/resources/response/#instance-variables_1","text":"headers","title":"Instance variables"},{"location":"api/tifeatures/resources/response/#methods_1","text":"","title":"Methods"},{"location":"api/tifeatures/resources/response/#delete_cookie_1","text":"def delete_cookie ( self , key : str , path : str = '/' , domain : Union [ str , NoneType ] = None , secure : bool = False , httponly : bool = False , samesite : Union [ Literal [ 'lax' , 'strict' , 'none' ], NoneType ] = 'lax' ) -> None","title":"delete_cookie"},{"location":"api/tifeatures/resources/response/#init_headers_1","text":"def init_headers ( self , headers : Union [ Mapping [ str , str ], NoneType ] = None ) -> None","title":"init_headers"},{"location":"api/tifeatures/resources/response/#render_1","text":"def render ( self , content : Any ) -> bytes","title":"render"},{"location":"api/tifeatures/resources/response/#set_cookie_1","text":"def set_cookie ( self , key : str , value : str = '' , max_age : Union [ int , NoneType ] = None , expires : Union [ int , NoneType ] = None , path : str = '/' , domain : Union [ str , NoneType ] = None , secure : bool = False , httponly : bool = False , samesite : Union [ Literal [ 'lax' , 'strict' , 'none' ], NoneType ] = 'lax' ) -> None","title":"set_cookie"}]}